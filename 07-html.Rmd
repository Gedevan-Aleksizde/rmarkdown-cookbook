# HTML 出力 {#html-output}

LaTeX と比べて HTML はおそらくページに分けた出力の組版が苦手です. しかし, 特に CSS や JavaScript と連携すれば, 結果を見せつける際にははるかに強力になります. 例えば HTML にインタラクティブアプリケーションを埋め込んだり, 動的に HTML ページの外観や, 内容すら修正できます. HTML 出力における有用ながらもシンプルな CSS と JavaScript のトリックは LaTeX 出力で再現するのがとても難しいこともあります (しばしば不可能なこともあります).

この章では, カスタム CSS の適用方法, カスタム HTML テンプレートの使い方, コードブロックのスタイル変更や折りたたみ, 表の内容の並び替え, そして HTML ページへのファイル埋め込みといった,  R Markdown の HTML 出力を向上するテクニックを紹介します.
In this chapter, we introduce techniques to enhance your HTML output from R Markdown, including how to apply custom CSS rules, use custom HTML templates, style or fold code blocks, arrange content in tabs, and embed files on HTML pages.

## カスタム CSS を適用する {#html-css}

HTML 文書の外観をカスタマイズしようと思うのなら, CSS と JavaScript を少しでも勉強することを強く勧めます. **blogdown** 本 [@blogdown2017] の [Appendix B](https://bookdown.org/yihui/blogdown/website-basics.html) には HTML, CSS, JavaScript の簡単なチュートリアルがあります.

CSS のセレクタと優先度のルールを理解することは初心者にとっては極めて重要です. さもなければ自分のカスタム CSS\index{CSS} が意図したように機能しないことに混乱することになるでしょう (おそらく優先度が十分でないから).

Rmd 文書に1つかそれ以上のカスタムスタイルシートを読み込ませるには, `css` オプション\index{出力オプション!css} を使うことができます. 例えばこのように.

```yaml
output:
  html_document:
    css: "style.css"
```

複数のスタイルシートを読み込ませるには, このようにブラケットで囲んだリストを使うことになるでしょう.

```yaml
output:
  html_document:
    css: ["style-1.css", "style-2.css"]
```

あるいは, Rmd 文書に 直接 CSS のルールを埋め込むのに, `css` コードチャンク\index{言語エンジン!css} を使うこともできます. 例えばこのように.

````md
We embed a `css` code chunk here.

```{css, echo=FALSE}`r ''`
p {
  font-size: 32px;
}
```
````

チャンクオプション `echo = FALSE`\index{チャンクオプション!echo} は CSS コードを出力にそのまま表示させないことを意味しますが, CSS コードを含む `<style>` タグは HTML 出力ファイルにも生成されます.

## セクションヘッダを中央揃えにする {#center-heading}

\@ref(html-css)節で言及した応用方法のように, CSS を見出しのアラインメント調整\index{CSS プロパティ!text-align}に使うことができます. 例えば以下のような CSS コードを使ってレベル1から3の見出しを中央揃えにしたいかもしれません.

```css
h1, h2, h3 {
  text-align: center;
}
```

Rmd 文書に CSS を適用する方法は\@ref(html-css)節を見てください.

## コードチャンクのスタイルを変更する {#chunk-styling}

<!-- https://stackoverflow.com/questions/41030477/changing-chunk-background-color-in-rmarkdown -->

チャンクオプションの `class.source`\index{チャンクオプション!class.source} と `class.output`\index{チャンクオプション!class.output} を使い, それぞれコードチャンクおよびそのテキスト出力のスタイルをカスタマイズできます. これらのオプションはクラス名\index{クラス!カスタムクラス}の文字列ベクトルを取ります (\@ref(attr-output)節参照). 例えば `class.source = "important"` は出力時にコードチャンクを含む HTML 要素に `important` というクラス名を持たせます. そこでこのクラスに CSS ルールを定義できます.^[CSS ではクラスは先頭にピリオド (`.`) を付けるため, この場合はルールは `.important` から始まります.] このルールは特定のコードチャンクやテキスト出力を強調したいときに役に立ちます.

デフォルトでは, R Markdown の HTML 出力は Bootstrap フレームワーク\index{Bootstrap}を読み込みます. Bootstrap は `"bg-primary"`, `"bg-success"`, `"bg-info"`, `"bg-warning"`,  `"bg-danger"` \index{クラス!Bootstrap クラス}\index{クラス!bg-primary}\index{クラス!bg-success}\index{クラス!bg-info}\index{クラス!bg-warning}\index{クラス!bg-danger}といったいくつかの [背景に対する CSS クラス](https://getbootstrap.com/docs/3.4/css/#helper-classes) が定義済みのため, コードと出力の外観の変更を容易にしてくれます.

以下はチャンクオプション `class.source = "bg-danger"` と `class.output = "bg-warning"` を使った例で, その出力は図\@ref(fig:chunk-bg)で見られます.

`r import_example('chunk-style.Rmd')`

```{r chunk-bg, echo=FALSE, fig.cap="Bootstrap で定義された背景色を使ったコードチャンクと出力ブロック"}
knitr::include_graphics("images/chunk-bg.png", dpi = NA)
```

任意のクラスを使って対応する CSS ルールを定義することもできます. この場合, \@ref(html-css)節で言及した方法を使ってカスタム CSS ルールを読み込ませなければなりません. 以下はその例です.

`r import_example('chunk-custom.Rmd')`

図\@ref(fig:chunk-border)がスタイルの出力です.

```{r chunk-border, echo=FALSE, fig.cap="明桃色の背景, 赤い太枠線をもつコードチャンク"}
knitr::include_graphics("images/chunk-border.png", dpi = NA)
```

文書内の全てのコードブロックにカスタムスタイルを塩要したいなら, グローバルな **knitr** オプションで `class.source` を設定します. 例えばこのように.

```{r, eval=FALSE}
knitr::opts_chunk$set(class.source='watch-out')
```

複数のクラスをコードブロックに適用できます. 例えば `class.source = c("important", "warning")` でコードブロックに "important" と "warning" という2つのクラスを持たせられます.

コードブロック全体ではなく, 内部の個別の要素を装飾したいならば, **flair** パッケージ\index{R パッケージ!flair} [@R-flair] の使用を検討してもよいかもしれません. このパッケージでコードの個別の部分 (特定の文字, 関数名, 引数など) をカスタムスタイル (例えば色, フォントサイズ, あるいはフォントのウエイト) で強調できます.

## コードブロックをスクロール可能にする (\*) {#html-scroll}

大量のコードやテキスト出力を HTML ページに表示するとき, 表示範囲の高さを制限したいかもしれません. そうしないとページはとてつもなく長くなり, それらを細かく読む気のない読者に読み飛ばしづらくなるかもしれません. この問題の解決法は複数あります. `html_document` フォーマットの `code_folding` オプション\index{出力オプション!code\_folding}を使うというのがその1つです. このオプションは出力文書のコードブロックを折りたたみ, また読者はボタンを押して展開することができます (詳細は\@ref(fold-show)節).

他の可能性としてはコードブロックが長すぎるとき, 高さを固定しスクロール可能にすることです. これは CSS プロパティの `max-height`\index{CSS プロパティ!max-height} と `overflow-y`\index{CSS プロパティ!overflow-y} で実現できます. 以下はその使用例の全容で, 出力は図\@ref(fig:html-scroll)になります.

`r import_example('html-scroll.Rmd')`

```{r html-scroll, echo=FALSE, fig.cap="カスタム CSS を使用したスクロール可能なコードブロック"}
knitr::include_graphics("images/html-scroll.png", dpi = NA)
```

上記の例では全てのコードブロックに大域的に 300px の高さ上限を定義しています. HTML 出力時にはコードブロックが `<pre>` タグで囲まれていることを思い出してください. それから `class` 属性に `<pre>` ブロックの高さを 100px に制限します. これは CSS セレクタ `pre[class]` が意味するところです. デフォルトではテキスト出力は `<pre> </pre>` に含まれ, R コードブロックは `<pre class="r"> </pre>` に含まれます (ここで `<pre>` タグが `class` 属性を持っていることに注意してください).

第2の R  コードチャンクからのテキスト出力の高さも 100px です. これが出力にたいして, カスタムクラス名 `scroll-100` を割り当て, 高さの上限を 100px に定義した理由です.

個別のコードブロックに対して異なる最大高さを指定したいならば, \@ref(hook-scroll)節の例を見ればよいでしょう.

## 全コードブロックを折りたたみ, かついくつかは表示する {#fold-show}

出力文書に書かれたコードブロックが読者に嫌がられるおそれがあるなら, はじめは折りたたんでおくという選択をするとよいかもしれません. 読者はボタンを押して表示を選ぶことができます.

```yaml
output:
  html_document:
    code_folding: hide
```

全てのコードブロックを最初から展開することもできます (よって読者は折りたたむことを選べます).

```yaml
output:
  html_document:
    code_folding: show
```

最初から全てのコードブロックを折りたたんだなら, チャンクオプション `class.source = "fold-show"` を使い特定のブロックを展開だけを最初から展開させておくこともできます. このように.

`r import_example('fold-show.Rmd')`

反対のこともできます. つまり, 最初から全てのコードブロックを表示するもののそれらの一部は表示させます. 例えばこのように.

````md
---
output:
  html_document:
    code_folding: show
---

```{r}`r ''`
1  # code is shown initially
```

```{r class.source = 'fold-hide'}`r ''`
2  # code is hidden initially
```
````

## 内容をタブブラウジングさせる {#html-tabs}

<!--https://stackoverflow.com/questions/38062706/rmarkdown-tabbed-and-untabbed-headings-->

HTML レポートの並列しているセクションをまとめる自然な方法の1つは, タブセットを使うことです. これは読者がページをスクロールして戻したり進めたりするかわりに, タブのタイトルをクリックすることで異なるセクションの内容を閲覧することを可能にします.

セクションをタブにするために, タブに変換する見出しより1レベル上の見出しにクラス属性 `.tabset`\index{tabset} を追加できます. 例えばレベル2の見出しに `.tabset` を追加するとそれ以降のレベル3の見出しが全てタブに変換されます. 以下は用例の全容です.

`r import_example('html-tabs.Rmd')`

出力を図\@ref(fig:html-tabs)に示します. 実際には一度に1つのタブしか見られないことに注意してください. この図は両方のタブがみられるよう2つのスクリーンショットを連結したものです.

```{r html-tabs, echo=FALSE, fig.cap="複数のセクションをタブに"}
knitr::include_graphics("images/html-tabs.png", dpi = NA)
```

タブに "pill" 効果を付けるため, さらに別の属性 `.tabset-pills` を上位レベルの見出しに追加することができます. これでタブは暗青色の背景になります.

```md
## Results {.tabset .tabset-pills}
```

デフォルトでは最初のタブがアクティブ (つまり表示されている) です. 他のタブを最初に表示させたいなら, そのセクションに `.active` 属性を追加するとよいでしょう.

タブセットを終わらせるには, 上位レベルのセクション見出しを新しく開始する必要があります. 新しいセクションの見出しは空にすることができます. 例えばこのように.

```md
## Results {.tabset}

### Tab One

### Tab Two

## {-}

上記のように番号なし (`{-}`) で空のセクション見出しがあれば,
タブセットを終了しさらなる段落を続けることができます.
```

## Rmd ソースファイルを HTML に埋め込む {#embed-rmd}

HTML 出力ページを共有するとき, Rmd ソースファイルもほしいかもしれません. 例えば Rmd ソースを変更し, 自分自身でレポートをコンパイルしたいかもしれません. Rmd ソースファイルのコピーを HTML に埋め込むにはオプション `code_download`\index{出力オプション!code\_download} を使うことができます.

```yaml
output:
  html_document:
    code_download: true
```

オプションが有効になると, HTML 出力ページはダウンロードボタンを持ち, 読者はそのボタンを押してソースファイルのダウンロードができます.

## HTML 出力に好きなファイルを埋め込む {#embed-file}

\@ref(embed-rmd)節で言及したように, HTML出力には Rmd ソース文書のコピーを埋め込めます. Rmd ファイル単体ではレポートを再現するのに不十分な場合もあるかもしれません. 例えばレポートに外部のデータファイルが必要かもしれません. HTML 出力ファイルに好きなファイルを埋め込んでくれる一連の関数が **xfun** パッケージ\index{R パッケージ!xfun} [@R-xfun] にあります. これらの関数を使うために, 以下の R パッケージを用意しておきます.

```{r, eval=FALSE}
xfun::pkg_load2(c('htmltools', 'mime'))
```

これで1つ以上のファイルやディレクトリを HTML 出力に埋め込むのに, コードチャンク内で `xfun::embed_file()`\index{xfun!embed\_file()}, `xfun::embed_files()`\index{xfun!embed\_files()}, `xfun::embed_dir()`\index{xfun!embed\_dir()}  を使えます. 例えばこのように.

````md
```{r echo=FALSE}`r ''`
# a single file
xfun::embed_file('source.Rmd')

# multiple files
xfun::embed_files(c('source.Rmd', 'data.csv'))

# a directory
xfun::embed_dir('data/', text = 'Download full data')
```
````

プログラミング的にファイルのリストを与えることもできます. 例えばこのように.

```{r eval=FALSE}
# embed all Rmd and csv files
xfun::embed_files(list.files('.', '[.](Rmd|csv)$'))
```

複数のファイルに対し, これらの関数はまず zip ファイルに圧縮してから, この zip ファイルを埋め込みます. これらの関数はリンクを返し, 読者は HTML ページのリンクをクリックして埋め込んだファイルをダウンロードすることができます.

ヘルプページ `?xfun::embed_file` またはブログ投稿 https://yihui.org/en/2018/07/embed-file/ でこれらの関数のより詳細な技術的情報を学ぶことができます. 同様のアイディアにより,  **downloadthis** package\index{R パッケージ!downloadthis} [@R-downloadthis] はダウンロードボタンを実装したことでユーザーはリンクではなくダウンロードボタンをクリックしてダウンロードできるようになります. ボタンを使うほうがお好みなら, こちらを使うことも検討するとよいでしょう.

## カスタム HTML テンプレートを使う (\*) {#html-template}

既に\@ref(latex-template)節では LaTeX テンプレートについて話しました. Pandoc が Markdown を HTML へ変換するに際しカスタム HTML テンプレート \index{テンプレート!HTML}を指定することもできます. 以下は簡単なテンプレートの例です.

```html
<html>
  <head>
    <title>$title$</title>
    $for(css)$
    <link rel="stylesheet" href="$css$" type="text/css" />
    $endfor$
  </head>
  <body>
  $body$
  </body>
</html>
```

テンプレートに `$title$`, `$body$` といったいくつかの変数が含まれているのがわかるでしょう. Pandoc 変数の完全なリストとそれぞれの意味については https://pandoc.org/MANUAL.html#templates で検索することができます.

テンプレートによってあなたは HTML 出力をカスタマイズする究極の力を得ることになります. 例えば好きな CSS スタイルシートや JavaScript コード, あるいはライブラリを `<head>` 内で読み込ませたりできます. あるいは文書が下書きか, 最終稿かを示すブーリアン変数 `draft` も使えます.

```html
<head>
<style type="text/css">
.logo {
  float: right;
}
</style>
</head>

<body>
<div class="logo">
$if(draft)$
<!-- use draft.png to show that this is a draft -->
<img src="images/draft.png" alt="Draft mode" />
$else$
<!-- insert the formal logo if this is final -->
<img src="images/logo.png" alt="Final version" />
$endif$
</div>

$body$
</body>
```

すると Rmd 文書の YAML メタデータ内で `draft` 変数に  `true` または `false` を設定できます. 例えばこのように.

```yaml
---
title: "An Important Report"
draft: true
---
```

テンプレートを Rmd 文書に適用するのに, テンプレートをファイルに保存し, `html_document` の `template` オプション\index{出力オプション!template}にファイルパスを与えることができます. 例えばこのように.


```yaml
output:
  html_document:
    template: my-template.html
```

**rmarkdown** パッケージは Pandoc のデフォルトテンプレートとは異なるカスタム HTML テンプレートをパッケージ内で読み込んで使用しています. Pandoc のデフォルトを使うには `template: null` で指定できます.

## 既存の HTML ファイルの内容を読み込む (\*) {#include-html}

`html_document` フォーマット (あるいはこのオプションをサポートしている他のフォーマット) の `includes` オプション\index{出力オプション!includes} があれば, 既存の HTML ファイルの本文を HTML 出力文書の3箇所のどこかで読み込むことができます. それらは `<head>`, `<body>` の開始時点, そして `</body>` の末尾です.

```yaml
output:
  html_document:
    includes:
      in_header: header.html
      before_body: before.html
      after_body: after.html
```

HTML にあまり詳しくないなら, \@ref(html-template)節がこのオプションをより理解するのに役に立つかもしれません.

`in_header` オプションを使うなら, CSS と JavaScript コードを `<head>` タグ内に挿入することができます. `before_body` を使うなら, バナーやロゴを表示するヘッダを埋め込むと良いでしょう. `after_body` を使うなら, フッタを読み込ませることができます. 例えばこのように.

```html
<div class="footer">Copyright &copy; John Doe 2020</div>
```

Sometimes you may want to include the content of an external HTML file in an arbitrary place of the body, which can be done with `htmltools::includeHTML()`. You pass the path of the HTML file to this function. It will read the file, and write its content to the output document. You may also use the technique in Section \@ref(raw-content), e.g.,

`````md
````{=html}
```{r, echo=FALSE, results='asis'}`r ''`
xfun::file_string('file.html')
```
````
`````

Please note that you must not include the content of a full HTML file in another HTML file, but can only include an HTML fragment. A full HTML file contains the `<html>` tag, which cannot be embedded in another `<html>` tag. Below is an invalid HTML document when a full HTML document is included in another HTML document:

```html
<html>
  <head>  </head>

  <body>
  Parent HTML file.
  
  <!-- htmltools::includeHTML() below -->
    <html>
      <head>  </head>
      <body>
      Child HTML file.
      </body>
    </html>
  <!-- included above -->

  </body>
</html>
```

If you run into problems when including an HTML file in an HTML output document, you may check if the HTML file contains the `<html>` tag.

There is an output format `html_fragment` in the **rmarkdown** package, which generates an HTML fragment instead of a full HTML document. If you want to include the compiled results of an Rmd document in another Rmd document, the former Rmd document may use the `html_fragment` format instead of the usual `html_document`.

If you want to include an Rmd or Markdown document instead of an HTML file, you may use child documents introduced in Section \@ref(child-document).

## Add a custom browser icon {#favicon}

Section \@ref(include-html) demonstrates that we can inject additional code into the HTML head, body, or footer with the `includes` option of the `html_document` format. This technique can be used to add a custom browser icon, called a favicon\index{figure!favicon}, to your HTML output.

Favicons are the website logos that are displayed in your browser's address bar, tab title, history, and bookmarks. For example, if you visit the CRAN website (https://cran.r-project.org) in Google Chrome, and look at the browser tab, you will see a small R logo. On mobile devices, favicons are also used in place of an App icon for websites that are pinned to the home screen.

To add a favicon to your HTML document, add the following line of code to a custom header file (such as the file `header.html` mentioned in Section \@ref(include-html)):

```html
<link rel="shortcut icon" href="{path to favicon file}" />
```

Recall that this file can be injected into the document `<head>` area using the YAML metadata\index{output option!includes}:

```yaml
output:
  html_document:
    includes:
      in_header: header.html
```

The path you provide to the `href` attribute in `<link>` should assume the same relative path structure as you would use to reference any other asset (e.g., an image or dataset). For the image itself, most small, square PNG files will work reasonably well. Bear in mind that a typical web browser will often display the image in a 16 x 16 pixel box, so simple designs are better.

If you want to ensure that each browser or platform on which your document is viewed uses a version of your icon with optimal resolution for its specific layout, you may use a service such as https://realfavicongenerator.net to generate a set of favicons and a slightly more complex version of the header HTML code. This service is currently used by the **pkgdown** package's `pkgdown::build_favicon()` function [@R-pkgdown] to make a set of favicons out of R package logos.

## Use the `<details>` disclosure element {#details-tag}

As mentioned in Section \@ref(html-scroll), we can fold source code chunks via the option `code_folding: hide` in the `html_document` format. Currently it is not possible to fold output blocks, but we can use some JavaScript tricks to make output foldable, too. This can be useful especially when the output is relatively long but not very important. We can fold it initially, and, if the reader is interested, they can unfold it to view the content. Figure \@ref(fig:details-tag) shows an example: you may click on the "Details" button to unfold the output.

```{r, details-tag, echo=FALSE, fig.show='hold', fig.cap='Wrap text output in the details element.', out.width=if(knitr::is_latex_output()) '100%'}
knitr::include_graphics(c('images/details-closed.png', 'images/details-open.png'), dpi = NA)
```

If you are viewing the HTML version of this book, you can actually see it in action below. If you are reading the PDF or printed version, such an interaction (clicking the "Details" button) is certainly not possible.

```{r}
1:100
```

Below is the full source Rmd document that includes the JavaScript code to find output blocks, and wrap them into the `<details>` tags.

```{js, echo=FALSE, include=knitr::is_html_output()}
(function() {
  var codes = document.querySelectorAll('pre:not([class])');
  var code, i, d, s, p;
  for (i = 0; i < codes.length; i++) {
    code = codes[i];
    p = code.parentNode;
    d = document.createElement('details');
    s = document.createElement('summary');
    s.innerText = 'Details';
    // <details><summary>Details</summary></details>
    d.appendChild(s);
    // move the code into <details>
    p.replaceChild(d, code);
    d.appendChild(code);
  }
})();
```

`r import_example('details-tag.Rmd')`

You may try to adapt the JavaScript code above to your own need. The key is to find out the elements to be wrapped into `<details>`:

```js
document.querySelectorAll('pre:not([class])');
```

The CSS selector `pre:not([class])` means all `<pre>` elements without the `class` attribute. You can also select other types of elements. For more about CSS selectors, see https://www.w3schools.com/css/css_selectors.asp. For more about the HTML tags `<details>` and `<summary>`, see https://www.w3schools.com/tags/tag_details.asp.

## Sharing HTML output on the web {#html-share}

One appealing aspect of rendering R Markdown to HTML files is that it is very easy to host these files on the Internet and share them just as one shares any other website. This section briefly summarizes numerous options for sharing the HTML\index{HTML hosting} documents that you have created.

### R-specific services

RStudio offers a number of services for publishing various types of content created in R Markdown to the Internet. These services make it particularly easy to publish content by using the RStudio IDE or the **rsconnect** package [@R-rsconnect].

- [**RPubs**](https://rpubs.com) enables free hosting of static single-file R Markdown content. It is easy to publish via the `Publish` button in the RStudio IDE or the `rsconnect::rpubsUpload()` function. Please see the "Getting Started" page (https://rpubs.com/about/getting-started) for more details.

- [**ShinyApps.io**](https://www.shinyapps.io) allows for hosting dynamic content that requires a server to run R. For example, one can host interactive R Markdown documents that include Shiny components.^[You may include Shiny components in an R Markdown document by setting the option `runtime: shiny` or `runtime: shiny_prerendered` in the YAML metadata. You will no longer be able to render your document to an HTML document as before; instead, you run your document with `rmarkdown::run()`. To learn more, please refer to @rmarkdown2018 (Chapter 19: https://bookdown.org/yihui/rmarkdown/shiny-documents.html).] ShinyApps.io is an analog to RPubs for Shiny applications. Apps and interactive R Markdown documents can be published using the push-button in the RStudio IDE or the `rsconnect::deployApp()` function. See the user guide (https://docs.rstudio.com/shinyapps.io/) for more details.

- [**bookdown.org**](https://bookdown.org/home/about/) offers free hosting specifically for books written with the **bookdown** package. You may easily publish static output files of your book using the `bookdown::publish_book()` function.

- [**RStudio Connect**](https://rstudio.com/products/connect/) is an enterprise product that organizations may run on their own servers. It can host a wide variety of content created in R (such as R Markdown documents, Shiny apps, and APIs) in a secured environment with document-level access controls, viewership history, and more. Content can be published to RStudio Connect using manual upload, the **rsconnect** package, or with GIT-based deployment.

### Static website services

In a few words, a simple static website is composed of any number of HTML files (typically containing an `index.html`, which is the homepage), JavaScript, CSS files, and additional content such as images. This collection of files can be hosted as-is on a web server and rendered in a web browser.

When R Markdown is rendered to the HTML output format, the result may be treated as a static website. Websites can range in complexity from a single, standalone HTML file (which is what we get when we use the default `self_contained: true` option), a set of files, or a sophisticated project like a website based on **blogdown** (which relies upon a static website generator). For more details, see [Section 2.1 on Static Sites](https://bookdown.org/yihui/blogdown/static-sites.html) of the **blogdown** book [@blogdown2017].

As a result, in addition to R-specific services, you may host your HTML document on many freely available static website hosting services. Commonly used options in the R community are: 

- [**GitHub Pages**](https://pages.github.com) makes it particularly easy to publish Markdown and HTML content straight from a GitHub repository. You may specify whether to host content from either the main branch's root, a `docs/` directory on the main branch, or a specific `gh-pages` branch. Publishing new content can be as simple as pushing new HTML files to your repository via GIT.

- [**GitLab Pages**](https://docs.gitlab.com/ce/user/project/pages/) offers similar functionality to GitHub Pages for GitLab repositories. GitLab deploys content stores in the `public/` directory of a repository. To build and publish content, you must provide a YAML file, `.gitlab-ci.yml` with instructions, but GitLab provides many helpful templates. For an example of hosting rendered HTML content, please see https://gitlab.com/pages/plain-html/-/tree/master. 

- [**Netlify**](https://www.netlify.com) is a platform to build and deploy static website content. It is a popular choice for web content created by the **blogdown** and **pkgdown** packages, but it can host all kinds of HTML files. There are many different publishing options including drag-and-drop, command line, or automated publishing from GitHub and GitLab repositories. Additionally, Netlify offers many helpful features such as website previews in pull requests. See the Netlify documentation (https://docs.netlify.com) or the RStudio webinar ["Sharing on Short Notice"](https://rstudio.com/resources/webinars/sharing-on-short-notice-how-to-get-your-materials-online-with-r-markdown/) for more details.

## Improve accessibility of HTML pages {#html-accessibility}

It is important to make your HTML output documents accessible\index{HTML!accessible} to readers who are visually impaired or blind. These readers often have to use special tools, such as screen readers, to _hear_ instead of visually reading your documents. Usually, screen readers can only read out text, but not (raster) images. This means you need to provide enough text hints to screen readers. The good news is that with some small efforts, you can actually greatly enhance the accessibility of your documents. Jonathan Godfrey has provided some tips in the article at https://r-resources.massey.ac.nz/rmarkdown/ on making accessible R Markdown documents.^[JooYoung Seo has also published a post about a few R packages to help visually impaired users at https://jooyoungseo.com/post/ds4blind/. It is not directly related to R Markdown, but it can be helpful for you to learn how blind users read graphs.] Based on this article, we highlight some tips below for the convenience of the readers of this book:

- HTML documents are often more accessible than PDF.

- Try to provide the Rmd source document along with the HTML output document if possible (e.g., Section \@ref(embed-rmd) demonstrates one way to do this). In case anything in the HTML document is not accessible, the blind reader may be able to figure it out from the Rmd source, or fix it in the source.

- Provide informative text tags to your graphics. At the useR! conference in 2014, Jonathan explained this issue to me in person. It was the first time that I had learned about the importance of the `alt` attribute of images on web pages\index{figure!alt text}.

    To understand this problem, first you have to know that images on web pages are generated by the HTML tag `<img />`. This tag has an `src` attribute, which points to the source of the image, e.g., `<img src="foo_figures/image.png" />`. Sighted readers can see the image, but it is hard for blind users to know anything about the image, because usually screen readers cannot read it, especially when it is a raster image (vector graphics can be better, such as SVG). In this case, it is helpful to provide a text hint, which screen readers can read out to the blind reader. This text hint can be provided in the `alt` attribute of the image, which stands for "alternate text."
    
    For images generated from code chunks in R Markdown, the `alt` attribute will be generated if you provide the chunk option `fig.cap` (i.e., figure caption). Alternatively, you can insert an image using the Markdown syntax `![]()`. You input the image path in parentheses, and the `alt` text in square brackets, e.g., `![an informative text](path/to/image.png)`.
    
    The `alt` text is not displayed to sighted readers on an HTML page. However, when you provide the figure caption or alternate text to an image, the `rmarkdown::html_document` format will render a visible figure caption element by default. If you do not want the real figure captions, you can turn off the `fig_caption` option, e.g., 
    
    ```yaml
    output:
      html_document:
        fig_caption: false
    ```
    
    In this case, the `alt` attributes will still be generated, but are no longer visible.

- Write mathematical content using the LaTeX syntax (e.g., `$ $` or `$$ $$`) instead of images. By default, R Markdown uses the MathJax library to render math content, and the result is readable to screen readers.

- Get rid of the leading hashes (`##`) in the text output of code chunks by setting the chunk option `comment = ""` (see Section \@ref(opts-comment)).

We are not experts on accessibility, so we recommend that you read the original article to learn more details.

## For hardcore HTML users (\*) {#html-hardcore}

In Section \@ref(latex-hardcore), we mentioned that if you feel the constraint of Markdown (due to its simplicity) is too strong, you can embed code chunks in a pure LaTeX document instead of Markdown. Similarly, if you are familiar and comfortable with writing raw HTML code, you can intermingle code chunks with HTML, too. Such documents have the conventional filename extension `.Rhtml`.\index{HTML!Rhtml}

In an `Rhtml` document, code chunks are embedded between `<!--begin.rcode` and `end.rcode-->`, and inline R expressions are embedded in `<!--rinline -->`. Below is a full `Rhtml` example. You can save it to a file named `test.Rhtml`, and use `knitr::knit("test.Rhtml")` to compile it. The output will be an HTML (`.html`) file. In RStudio, you can also hit the `Knit` button on the toolbar to compile the document.

`r import_example('knitr.Rhtml')`
