# チャンクオプション {#chunk-options}

図\@ref(fig:rmdworkflow)が表すように, **knitr** パッケージは R Markdown においてきわめて重要な役割を持ちます. この章と次の3つの章では **knitr** に関連するレシピをお見せします. 

R のチャンクを処理する際には, **knitr** の挙動を微調整するのに 50 のチャンクオプション\index{チャンクオプション}が使われる可能性があります. 完全なリストは <https://yihui.org/knitr/options/> のオンラインドキュメントをご覧ください.^[**訳注**: 翻訳者に寄る日本語訳はこちら: https://gedevan-aleksizde.github.io/knitr-doc-ja/options.html] `r if (knitr::is_latex_output()) '利便性のため, 本書の 付録\\@ref(full-options)としてこのドキュメントのコピーを掲載しました.'`

続く各節では, チャンクオプションを個別のコードチャンクに適用する例のみを示します. ただし, どのチャンクオプションもグローバル設定で文書全体に適用できるので, コードチャンク1つ1つに繰り返しオプションを書かなくても良いという事実を覚えてください. グローバルにチャンクオプションを設定するには, いずれかのコードチャンクで `knitr::opts_chunk$set()`\index{チャンクオプション!グローバルに設定する} を呼び出してください. たいていは文書の中で最初のチャンクオプションです. 例えばこのように.

````md
```{r, include=FALSE}`r ''`
knitr::opts_chunk$set(
  comment = "#>", echo = FALSE, fig.width = 6
)
```
````

## チャンクオプションに変数を使う {#chunk-variable}

大抵の場合, 例えば `fig.width = 6` のようにチャンクオプションは定数をとりますが, 簡単であるか複雑であるかに関わらず, 任意の R コードを与えることもできます. 単純なケースはチャンクオプションに通せる変数\index{チャンクオプション!変数の値}です. 変数もまた R コードであることに注意してください. 例えば文書の冒頭で変数として図の幅を定義して, その後の他のコードチャンクで使うことができるので, それ以降の幅を簡単に変更できます.

````md
```{r}`r ''`
my_width <- 7
```

```{r, fig.width=my_width}`r ''`
plot(cars)
```
````

以下はチャンクオプショで `if-else` 文を使う例です\index{チャンクオプション!if else ロジック}.

````md
```{r}`r ''`
fig_small <- FALSE  # 大きい図に対しては TRUE に変更
width_small <- 4
width_large <- 8
```

```{r, fig.width=if (fig_small) width_small else width_large}`r ''`
plot(cars)
```
````

さらに以下にもう1つの例として, 必要なパッケージが使用可能な場合のみコードチャンクを評価する (つまり実行する) ものを示します.

````md
```{r, eval=require('leaflet')}`r ''`
library(leaflet)
leaflet() %>% addTiles()
```
````

意図が分からない方のために説明しますと, `require('package')` はパッケージが使用可能なら `TRUE` を返し, そうでないなら `FALSE` を返します.

## エラーが起こっても中止しない {#opts-error}

時として, 例えば R のチュートリアルのために, わざとエラーを見せたいこともあるかもしれません. デフォルトでは, Rmd 文書のコードチャンクでのエラーは R の処理を停止させます. R の処理を停めることなくエラーを見せたいなら, 例えばこのように `error = TRUE`\index{チャンクオプション!error} チャンクオプションを使うと良いでしょう.

````md
```{r, error=TRUE}`r ''`
1 + "a"
```
````

Rmd 文書をコンパイルすると, 出力文書上でのエラーメッセージはこのような見た目になります.

```{r, error=TRUE, echo=FALSE, comment=''}
1 + "a"
```

R Markdown では `error = FALSE` がデフォルトであり, これはコードチャンクの実行時のエラーは処理を停止させます.

## 同じグラフを複数の出力フォーマットに {#dev-vector}

ほとんどの場合, 1つの図に対して `png` や `pdf` といった1つの画像フォーマットにしたいでしょう. 画像フォーマットはチャンクオプション `dev`\index{チャンクオプション!dev}\index{図!グラフィックデバイス} で操作できます. つまり, グラフをレンダリングするグラフィックデバイスを意味します. このオプションはデバイス名のベクトルをとることができます. これが例です.

````md
```{r, dev=c('png', 'pdf', 'svg', 'tiff')}`r ''`
plot(cars)
```
````

出力文書には最初のフォーマットのみが使われますが, 残りのフォーマットに対応する画像も生成されます. 例えば, レポートでは `png` 画像を掲載するが, 同じ画像の `tiff` 形式が求められるというように, 追加で異なるフォーマットの図の提出が要求されるような場合に便利でしょう.

デフォルトでは, 典型として画像ファイルは出力文書がレンダリングされた後に削除されます. ファイルを保持する方法は\@ref(keep-files)節を参照してください.

## 時間のかかるチャンクをキャッシュする {#cache}

コードチャンクの実行に時間がかかる場合, チャンクオプション `cache = TRUE`\index{チャンクオプション!cache}\index{キャッシュ} で結果をキャッシュすることを検討すると良いでしょう. キャッシュが有効な場合, このコードが以前にも実行され, その後コードに変更がないならば, **knitr** はこの実行を飛ばします. コードチャンクを変更し, つまりコードまたはチャンクオプションを修正したなら, 過去のキャッシュは自動的に無効になり **knitr** はもう一度チャンクをキャッシュします.

キャッシュされたコードチャンクに関しては, チャンクが再度実行されたかのように, 過去の実行結果から出力とオブジェクトが自動的に読み込まれます. キャッシュを取ることは結果を計算するより読み込んだほうがはるかに速いという場合に役に立ちます. しかしながら, うまい話というのは世に存在しません. あなたの使う場面にもよりますが, キャッシュがどのように動作するかをより学びぶ必要があるかもしれません, 特に [cache invalidation](https://yihui.org/en/2018/06/cache-invalidation/) を. これにより,  **knitr**がしょっちゅうキャッシュを無効化したり, あるいは時に無効化が十分できていない理由に混乱することなく, あなたはキャッシュの利点を最大限活かすことができます.

最も適切なキャッシュの使用例は, コードチャンク内での計算に非常に時間がかかるり, そして `options()` を使って R のグローバルオプションを変更するといった副産物 (このような変更はキャッシュされません) の一切ない R オブジェクトの保存と再読込に使うことです. コードチャンクに副産物があるなら, キャッシュを使わないことをお薦めします.

最初のほうで簡単に書いたように, キャッシュはチャンクオプションに依存します. もし `include` 以外のチャンクオプションを変更したら,  キャッシュは無効化されます. この性質はよくある問題を解決するのに使うことができます. それは外部データファイルを読み込むときに, ファイルが更新されていたならキャッシュを無効化したい, というような場合です. 単純に `cache = TRUE` を使うだけでは不十分です.

````md
```{r import-data, cache=TRUE}`r ''`
d <- read.csv('my-precious.csv')
```
````

**knitr** にデータファイルが変更されたかどうかを教えなければなりません. 1つの方法として別のチャンクオプション `cache.extra = file.mtime('my-precious.csv')`\index{チャンクオプション!cache.extra} を, あるいはより厳密に `cache.extra = tools::md5sum('my-precious.csv')` を追加することがあります. 前者はファイルの更新時刻が変更されたらキャッシュを無効化する, という意味です. 後者はファイルの中身が変更されたらキャッシュを更新するということです. `cache.extra` は **knitr** の組み込みのチャンクオプションではないということに注意してください. 他の組み込みのオプション名と競合しない限り, この用途のオプションには好きな名前を使うことができます.

同様に, 他の情報をキャッシュと関連付けることができます. 例えば R のバージョンなら `cache.extra = getRversion()`, 日付なら `cache.extra = Sys.Date()`, オペレーティングシステムなら `cache.extra = Sys.info()[['sysname']]` というようにすると, これらの条件が変更されたときにキャッシュは正しく無効化されます.

文書全体で `cache = TRUE` を設定することはお薦めしません. キャッシュはかなり扱いにくいものです. そうではなく, 実行に時間がかかり副産物のないとはっきりしているコードチャンクに対してのみ個別にキャッシュを有効化することをお薦めします.

**knitr** のキャッシュの設計に不満があるなら, 自分でオブジェクトのキャッシュを取ることもできます. 以下はごく簡単な例です.

```{r, eval=FALSE}
if (file.exists('results.rds')) {
  res = readRDS('results.rds')
} else {
  res = compute_it()  # a time-consuming function
  saveRDS(res, 'results.rds')
}
```

この例では, キャッシュを無効化する唯一の, そして簡単な方法は `result.rds`` ファイルを削除することです. この簡単なキャッシュのしくみが気に入ったなら, \@ref(cache-rds)節で紹介する `xfun::cache_rds()`\index{xfun!cache\_rds()} を使うと良いでしょう.

## 複数の出力フォーマットに対してチャンクをキャッシュする {#cache-path}

`cache = TRUE`\index{チャンクオプション!cache}\index{caching} でキャッシュが有効化されたとき, **knitr** は R コードチャンクで生成された R オブジェクトをキャッシュデータベースに書き込みます. これで次回から再読込ができます. キャッシュデータベースのパスはチャンクオプション `cache.path`\index{chunk option!cache.path} によって決まります. デフォルトでは R Markdown は出力フォーマットごとに異なるキャッシュのパスを使用するので, 時間のかかるコードチャンクは出力フォーマットごとに丸ごと実行されることになります. これは不便かもしれませんが, これがデフォルトの挙動であることには理由があります. コードチャンクの出力は, 出力フォーマットに依存します. 例えばグラフを生成した時, 出力フォーマットが `word_document` なら `![text](path/to/image.png)` のような Markdown 構文で図を掲載できますし, 出力フォーマットが `html_document` なら `<img src="path/to/image.png" />` が使えます.

コードチャンクにグラフなど副作用が一切ないとき, 全ての出力フォーマットで同じキャッシュデータベースを使っても安全であり, 時間を節約できます. 例えば大きなデータオブジェクトを読み込むか時間のかかるモデルを実行するかというときは, 結果は出力フォーマットに依存しませんので, 同じキャッシュデータベースを使うことができます. コードチャンクに `cache.path` を指定することでデータベースのパスを指定できます. これが例です.

````md
```{r important-computing, cache=TRUE, cache.path="cache/"}`r ''`
```
````

R Markdown ではデフォルトでは `cache.path = "INPUT_cache/FORMAT/"` で, `INPUT` には入力ファイル名が, `FORMAT` には `html`, `latex`, `docx` といった出力フォーマット名が入ります.

## 巨大オブジェクトをキャッシュする {#cache-lazy}

チャンクオプション  `cache = TRUE` を使うと, キャッシュされたオブジェクトは R セッション内で遅延読み込みされます. これはオブジェクトが実際にコード内で使用されるまで\index{caching}キャッシュデータベースから読み込まれないことを意味します. 以降の文書内で全てのオブジェクトが使われるわけではない場合にメモリを多少節約することができます. 例えば大きなデータオブジェクトを読み込んだが, 以降の分析ではその一部しか使わないなら, 元のデータオブジェクトはキャッシュデータベースから読み込まれません.

````md
```{r, read-data, cache=TRUE}`r ''`
full <- read.csv("HUGE.csv")
rows <- subset(full, price > 100)
# next we only use `rows`
```

```{r}`r ''`
plot(rows)
```
````

しかし, オブジェクトが大きすぎるときは, このようなエラーに遭遇するかもしれません.

```r
Error in lazyLoadDBinsertVariable(vars[i], ... 
  long vectors not supported yet: ...
Execution halted
```

この問題が発生したら, チャンクオプション `cache.lazy = FALSE`\index{チャンクオプション!cache.lazy} で遅延読み込みを無効にできます. チャンク内の全てのオブジェクトが即座にメモリに読み込まれます.

## コード, テキスト出力, メッセージ, グラフを隠す {#hide-one}

デフォルトでは, **knitr** はコードチャンクから, ソースコード・テキスト出力・メッセージ・警告・エラー・グラフといった可能な全ての出力を表示します. これらに対応するコードチャンクを使い, 個別に隠すことができます.

`r import_example('knitr-hide.Rmd')`

**knitr** に関するよくある質問の1つは, パッケージ読み込み時のメッセージを隠す方法です. 例えば `library(tidyverse)` や `library(ggplot2)` を使ったとき, いくつかの読み込みメッセージが現れます. このようなメッセージはチャンクオプション `message = FALSE` で抑制することもできます.

インデックスによってこれらの要素を表示したり隠したり選択することも出来ます. 以下の例では, ソースコードの4つ目と5つ目の式を表示し, 最初の2つのメッセージと2つ目と3つ目の警告を隠しています.  コメントも式1つとして数えられることに注意してください.

````md
```{r, echo=c(4, 5), message=c(1, 2), warning=2:3}`r ''`
# 乱数 N(0, 1) を生成する方法の1つ
x <- qnorm(runif(10))
# だが rnorm() を使うほうが実用的
x <- rnorm(10)
x

for (i in 1:5) message('ここにメッセージ ', i)

for (i in 1:5) warning('ここにメッセージ ', i)
```
````

負のインデックスを使用することもできます. 例えば `echo = -2`\index{チャンクオプション!echo} は出力部のソースコードの2つ目の式を排除します.

同様に, `fig.keep` オプション\index{チャンクオプション!fig.keep}に対してインデックスを使うことでどのグラフを表示あるいは隠すかを選ぶこともできます. 例えば `fig.keep = 1:2` は最初の2つのグラフを残すことを意味します. このオプションにはいくつかのショートカットがあります. `fig.keep = "first"` は最初のグラフのみを残し, `fig.keep = "last"` は最後のグラフのみを残し, `fig.keep = "none"` は全てのグラフを破棄します. 2つのオプション `fig.keep = "none"` と `fig.show = "hide"` は異なることに注意してください. 前者はそもそも画像ファイルを生成しませんが, 後者はグラフを生成し隠すだけです.

`html_document` 出力のソースコードブロックに対して, `echo = FALSE` で完全に省略したくないというならば, ページ上でブロックを折りたたみ, ユーザーが展開ボタンを押して展開させるようにできる方法を書いた\@ref(fold-show)節を見ると良いかもしれません. 

## チャンクの出力を全て隠す {#hide-all}

ときには出力を全く表示させずにコードチャンクを実行したいかもしれません. \@ref(hide-one)節で言及したような方法で個別にオプションを使うのではなく, ただ1つ `include = FALSE`\index{チャンクオプション!include} を使うことで出力全体を抑制できます. これが例です.

````md
```{r, include=FALSE}`r ''`
# ここに何らかの R コード
```
````

`include=FALSE` オプションがあると, `eval = FALSE` の指定がない限りコードチャンクは評価されますが, 出力は完全に抑制されます. コードも, テキスト出力も, メッセージもグラフも見えなくなります.

## テキスト出力をソースコードとまとめる {#opts-collapse}

テキスト出力ブロックとソースコードブロックの間隔が空きすぎていると感じたら, チャンクオプション  `collapse = TRUE`\index{チャンクオプション!collapse} でテキスト出力をソースブロックと連結することを検討するとよいでしょう. `collapse = TRUE` としたとき, 出力はこのようになります.

```{r, test-collapse, collapse=TRUE}
1 + 1
1:10
```

以下は同じチャンクですが `collapse = TRUE` オプションがありません. デフォルトは `FALSE` です.

```{r, test-collapse}
```

## R のソースコードを整形する {#opts-tidy}

チャンクオプション `tidy = TRUE`\index{チャンクオプション!tidy} を設定すると, **formatR** パッケージ\index{R パッケージ!formatR} [@R-formatR] の `tidy_source()` 関数によって R のソースコードが整形されます. `tidy_source()` 関数は, ほとんどの演算子の前後にスペースを追加する, 適切なインデントをする, 代入演算子 `=` を `<-` に置き換えるなど, いくつかの観点でソースコードを整形します. チャンクオプション `tidy.opts`\index{チャンクオプション!tidy.opts} には `formatR::tidy_source()` に与えられる引数のリストが使えます. これが例です. 

`r import_example('tidy-opts.Rmd')`

整形後の出力はこうなります.

```{r, child='examples/tidy-opts.Rmd', results='hide'}
```

\@ref(text-width)節ではテキストの幅を制御する方法について言及しました. ソースコードの幅を制御したいなら, `tidy = TRUE` としたときに `width.cutoff` 引数を試してみると良いでしょう. これが例です.

`r import_example('tidy-width.Rmd')`

出力はこうなります.

```{r, child='examples/tidy-width.Rmd', results='hide'}
```

使用可能な引数を知るにはヘルプページ `?formatR::tidy_source` を読んでください. そして https://yihui.org/formatR/ で使用例とこの関数の限界を理解してください.

`tidy = styler` を設定したら, コード整形には代わりに **styler** パッケージ [@R-styler]\index{R パッケージ!styler} が使われるでしょう. R コードは `styler::style_text()` 関数で整形されます. **styler** パッケージは **formatR** よりも豊富な機能を持ちます. 例えば, 引数のアラインメントができたりパイプ演算子 `%>%` のあるコードも対処できたりします. チャンクオプション `tidy.opts`\index{チャンクオプション!tidy.opts} には `styler::style_text()` への引数を使うこともできます. これが例です.

````md
```{r, tidy='styler', tidy.opts=list(strict=FALSE)}`r ''`
# 代入演算子のアラインメント
a   <- 1#one variable
abc <- 2#another variable
```
````

デフォルトでは `tidy = FALSE` であり, あなたのコードは整形されません.

## テキストを生の Markdown として出力する (\*) {#results-asis}

デフォルトではコードチャンクからのテキスト出力は冒頭に2つハッシュを置いて, テキストをそのまま書き出します (\@ref(opts-comment)節参照). **knitr** は出力をコードブロックで囲むため, テキストはそのまま表示されます. 例えば `1:5` というコードの生の出力はこうなります.

````md
```
## [1] 1 2 3 4 5
```
````

時には生のテキストをそのまま出力するのではなく, Markdown 構文として扱いたいこともあるでしょう. 例えば `cat('# これは見出しです')` でセクション見出しを書きたい時があるかもしれませんが, 生の出力はこうなります.

````md
```
## # これは見出しです
```
````

テキストをコードブロックで囲んでほしくない, あるいは冒頭のハッシュもいらない. つまり, 生の出力が `cat()` に与えた文字列そのままになるようにしたい, というわけです.

````md
# This is a header
````

これを解決するのはチャンクオプション `results = 'asis'`\index{チャンクオプション!results} です. このオプションは テキスト出力をコードブロックで囲むのではなく, "as is" (そのまま) 扱うよう **knitr** に指示します. R コードから動的にコンテンツを生成したい時に, このオプションは特に有用でしょう. 例えば以下のコードチャンクと `results = 'asis'` オプションで, `iris` データから列名のリストを生成します.

```{r, iris-asis, results='asis'}
cat(paste0('- `', names(iris), '`'), sep = '\n')
```

ハイフン (`-`) は番号のない箇条書き意味する Markdown 構文です.  バッククォートはオプションです. `results = 'asis'` オプションなしで上記のコードチャンクがそのまま出力されるのを見ることもできます.

```{r, iris-asis, comment=''}
```

以下は, セクション見出し, パラグラフ,  `mtcars` データの全ての列に対して`for` ループ内で作成したグラフを表示する例の全貌です

`r import_example('generate-content.Rmd')`

Please note that we added line breaks (`\n`) excessively in the code. That is because we want different elements to be separated clearly in the Markdown content. It is harmless to use an excessive number of line breaks between different elements, whereas it can be problematic if there are not enough line breaks. For example, there is much ambiguity in the Markdown text below:

```md
# Is this a header?
Is this a paragraph or a part of the header?
![How about this image?](foo.png)
# How about this line?
```

With more empty lines (which could be generated by `cat('\n')`), the ambiguity will be gone:

```md
# Yes, a header!

And definitely a paragraph.

![An image here.](foo.png)

# Absolutely another header
```

The `cat()` function is not the only function that can generate text output. Another commonly used function is `print()`. Please note that `print()` is often _implicitly_ called to print objects, which is why you see output after typing out an object or value in the R console. For example, when you type `1:5` in the R console and hit the `Enter` key, you see the output because R actually called `print(1:5)` implicitly. This can be highly confusing when you fail to generate output inside an expression (such as a `for`-loop) with objects or values that would otherwise be correctly printed if they were typed in the R console. This topic is quite technical, and I have written the blog post ["The Ghost Printer behind Top-level R Expressions"](https://yihui.org/en/2017/06/top-level-r-expressions/) to explain it. If you are not interested in the technical details, just remember this rule: if you do not see output from a `for`-loop, you should probably print objects explicitly with the `print()` function.

## Remove leading hashes in text output {#opts-comment}

<!-- https://stackoverflow.com/questions/15081212/remove-hashes-in-r-output-from-r-markdown-and-knitr -->

By default, R code output will have two hashes `##` inserted in front of the text output. We can alter this behavior through the `comment` chunk option\index{chunk option!comment}, which defaults to a character string `"##"`. We can use an empty string if we want to remove the hashes. For example:

````md
```{r, comment=""}`r ''`
1:100
```
````

Of course, you can use any other character values, e.g., `comment = "#>"`. Why does the `comment` option default to hashes? That is because `#` indicates comments in R. When the text output is commented out, it will be easier for you to copy all the code from a code chunk in a report and run it by yourself, without worrying about the fact that text output is not R code. For example, in the code chunk below, you can copy all four lines of text and run them safely as R code:

```{r, comment-hash, collapse=TRUE}
1 + 1
2 + 2
```

If you remove the hashes via `comment = ""`, it will not be easy for you to run all the code, because if you copy the four lines, you will have to manually remove the second and fourth lines:

```{r, comment-hash, comment="", collapse=TRUE}
```

One argument in favor of `comment = ""` is that it makes the text output look familiar to R console users. In the R console, you do not see hashes in the beginning of lines of text output. If you want to truly mimic the behavior of the R console, you can actually use `comment = ""` in conjunction with `prompt = TRUE`\index{chunk option!prompt}, e.g.,

````md
```{r, comment="", prompt=TRUE}`r ''`
1 + 1
if (TRUE) {
  2 + 2
}
```
````

The output should look fairly familiar to you if you have ever typed and run code in the R console, since the source code contains the prompt character `>` and the continuation character `+`:

```{r, comment="", prompt=TRUE, collapse=TRUE}
1 + 1
if (TRUE) {
  2 + 2
}
```

## Add attributes to text output blocks (\*) {#attr-output}

In Section \@ref(chunk-styling), we showed some examples of styling source and text output blocks based on the chunk options `class.source`\index{chunk option!class.source} and `class.output`\index{chunk option!class.output}. Actually, there is a wider range of similar options in **knitr**, such as `class.message`\index{chunk option!class.message}, `class.warning`\index{chunk option!class.warning}, and `class.error`\index{chunk option!class.error}. These options can be used to add class names to the corresponding text output blocks, e.g., `class.error` adds classes to error messages when the chunk option `error = TRUE`\index{chunk option!error} (see Section \@ref(opts-error)). The most common application of these options may be styling the output blocks with CSS rules\index{CSS} defined according to the class names, as demonstrated by the examples in Section \@ref(chunk-styling).

Typically, a text output block is essentially a fenced code block, and its Markdown source looks like this:

````md
```{.className}
lines of output
```
````

When the output format is HTML, it is usually^[It could also be converted to `<div class="className"></div>`. You may view the source of the HTML output document to make sure.] converted to:

````html
<pre class="className">
<code>lines of output</code>
</pre>
````

The `class.*` options control the `class` attribute of the `<pre>` element, which is the container of the text output blocks that we mentioned above.

In fact, the class is only one of the possible attributes of the `<pre>` element in HTML. An HTML element may have many other attributes, such as the width, height, and style, etc. The chunk options `attr.*`, including `attr.source`\index{chunk option!attr.source}, `attr.output`\index{chunk option!attr.output}, `attr.message`\index{chunk option!attr.message}, `attr.warning`\index{chunk option!attr.warning}, and `attr.error`\index{chunk option!attr.error}, allow you to add arbitrary attributes to the text output blocks. For example, with `attr.source = 'style="background: pink;"'`, you may change the background color of source blocks to pink. The corresponding fenced code block will be:

````md
```{style="background: pink;"}
...
```
````

And the HTML output will be:

````html
<pre style="background: pink;">
...
</pre>
````

You can find more examples in Section \@ref(number-lines) and Section \@ref(hook-scroll).

As a technical note, the chunk options `class.*` are just special cases of `attr.*`, e.g., `class.source = 'numberLines'` is equivalent to `attr.source = '.numberLines'` (note the leading dot here), but `attr.source` can take arbitrary attribute values, e.g., `attr.source = c('.numberLines', 'startFrom="11"')`.

These options are mostly useful to HTML output. There are cases in which the attributes may be useful to other output formats, but these cases are relatively rare. The attributes need to be supported by either Pandoc (such as the `.numberLines` attribute, which works for both HTML and LaTeX output), or a third-party package (usually via a Lua filter, as introduced in Section \@ref(lua-filters)).

## Post-process plots (\*) {#fig-process}

After a plot is generated from a code chunk, you can post-process the plot file via the chunk option `fig.process`\index{chunk option!fig.process}\index{figure!post-processing}, which should be a function that takes the file path as the input argument and returns a path to the processed plot file. This function can have an optional second argument `options`, which is a list of the current chunk options.

Below we show an example of adding an R logo to a plot using the extremely powerful **magick** package [@R-magick]\index{R package!magick}. If you are not familiar with this package, we recommend that you read its online documentation or package vignette, which contains lots of examples. First, we define a function `add_logo()`:

```{r}
add_logo = function(path, options) {
  # the plot created from the code chunk
  img = magick::image_read(path)
  # the R logo
  logo = file.path(R.home("doc"), "html", "logo.jpg")
  logo = magick::image_read(logo)
  # the default gravity is northwest, and users can change it via the chunk
  # option magick.gravity
  if (is.null(g <- options$magick.gravity)) g = 'northwest'
  # add the logo to the plot
  img = magick::image_composite(img, logo, gravity = g)
  # write out the new image 
  magick::image_write(img, path)
  path
}
```

Basically the function takes the path of an R plot, adds an R logo to it, and saves the new plot to the original path. By default, the logo is added to the upper-left corner (northwest) of the plot, but users can customize the location via the custom chunk option `magick.gravity` (this option name can be arbitrary).

Now we apply the above processing function to the code chunk below with chunk options `fig.process = add_logo` and `magick.gravity = "northeast"`, so the logo is added to the upper-right corner. See Figure \@ref(fig:magick-logo) for the actual output.

```{r, magick-logo, dev='png', fig.retina=1, fig.process=add_logo, magick.gravity = 'northeast', fig.cap='Add the R logo to a plot via the chunk option fig.process.'}
par(mar = c(4, 4, .1, .1))
hist(faithful$eruptions, breaks = 30, main = '', col = 'gray', border = 'white')
```

After you get more familiar with the **magick** package, you may come up with more creative and useful ideas to post-process your R plots.

Finally, we show one more application of the `fig.process` option. The `pdf2png()` function below converts a PDF image to PNG. In Section \@ref(graphical-device), we have an example of using the `tikz` graphical device to generate plots. The problem is that this device generates PDF plots, which will not work for non-LaTeX output documents. With the chunk options `dev = "tikz"` and `fig.process = pdf2png`, we can show the PNG version of the plot in Figure \@ref(fig:dev-tikz).

```{r}
pdf2png = function(path) {
  # only do the conversion for non-LaTeX output
  if (knitr::is_latex_output()) return(path)
  path2 = xfun::with_ext(path, "png")
  img = magick::image_read_pdf(path)
  magick::image_write(img, path2, format = "png")
  path2
}
```

## High-quality graphics (\*) {#graphical-device}

The **rmarkdown** package has set reasonable default graphical devices for different output formats. For example, HTML output formats use the `png()` device, so **knitr** will generate PNG plot files, and PDF output formats use the `pdf()` device, etc. If you are not satisfied with the quality of the default graphical devices, you can change them via the chunk option `dev`\index{chunk option!dev}. All possible devices supported by **knitr** are: `r knitr::combine_words(names(knitr:::auto_exts), before = '\x60"', after = '"\x60')`.

Usually, a graphical device name is also a function name. If you want to know more about a device\index{figure!device}, you can read the R help page. For example, you can type `?svg` in the R console to know the details about the `svg` device, which is included in base R. Note that the `quartz_XXX` devices are based on the `quartz()` function, and they are only available on macOS. The `CairoXXX` devices are from the add-on R package **Cairo** [@R-Cairo], the `Cairo_XXX` devices are from the **cairoDevice** package [@R-cairoDevice], the `svglite` device is from the **svglite** package [@R-svglite], and `tikz` is a device in the **tikzDevice** package [@R-tikzDevice]. If you want to use devices from an add-on package, you have to install the package first.\index{R package!graphics devices}

Usually, vector graphics have higher quality than raster graphics, and you can scale vector graphics without loss of quality. For HTML output, you may consider using `dev = "svg"` or `dev = "svglite"` for SVG plots. Note that SVG is a vector graphics format, and the default `png` device produces a raster graphics format.

For PDF output, if you are really picky about the typeface in your plots, you may use `dev = "tikz"`, because it offers native support for LaTeX, which means all elements in a plot, including text and symbols, are rendered in high quality through LaTeX. Figure \@ref(fig:dev-tikz) shows an example of writing LaTeX math expressions in an R plot rendered with the chunk option `dev = "tikz"`.

```{r, dev-tikz, dev='tikz', tidy=FALSE, fig.cap='A plot rendered via the tikz device.', fig.dim=c(6, 4), fig.align='center', fig.process=pdf2png, cache=TRUE}
par(mar = c(4, 4, 2, .1))
curve(dnorm, -3, 3, xlab = '$x$', ylab = '$\\phi(x)$',
      main = 'The density function of $N(0, 1)$')
text(-1, .2, cex = 3, col = 'blue',
  '$\\phi(x)=\\frac{1}{\\sqrt{2\\pi}}e^{\\frac{-x^2}{2}}$')
```

Note that base R actually supports math expressions, but they are not rendered via LaTeX (see `?plotmath` for details). There are several advanced options to tune the typesetting details of the `tikz` device. You may see `?tikzDevice::tikz` for the possibilities. For example, if your plot contains multibyte characters, you may want to set the option:

```{r, eval=FALSE}
options(tikzDefaultEngine = 'xetex')
```

That is because `xetex` is usually better than the default engine `pdftex` in processing multibyte characters in LaTeX documents.

There are two major disadvantages of the `tikz` device. First, it requires a LaTeX installation, but this may not be too bad (see Section \@ref(install-latex)). You also need a few LaTeX packages, which can be easily installed if you are using TinyTeX:

```{r, tikz-packages, eval=!tinytex:::check_installed(c('pgf', 'preview', 'xcolor')), message=FALSE}
tinytex::tlmgr_install(c('pgf', 'preview', 'xcolor'))
```

Second, it is often significantly slower to render the plots, because this device generates a LaTeX file and has to compile it to PDF. If you feel the code chunk is time-consuming, you may enable caching by the chunk option `cache = TRUE` (see Section \@ref(cache)).

For Figure \@ref(fig:dev-tikz), we also used the chunk option `fig.process = pdf2png`\index{chunk option!fig.process}, where the function `pdf2png` is defined in Section \@ref(fig-process) to convert the PDF plot to PNG when the output format is not LaTeX. Without the conversion, you may not be able to view the PDF plot in the online version of this book in the web browser.

## Step-by-step plots with low-level plotting functions (\*) {#low-plots}

For R graphics, there are two types of plotting functions: high-level plotting functions create new plots, and low-level functions add elements to existing plots. You may see Chapter 12 ("Graphical procedures") of the R manual [_An Introduction to R_](https://cran.r-project.org/doc/manuals/r-release/R-intro.html) for more information.

By default, **knitr** does not show the intermediate plots when a series of low-level plotting functions\index{figure!intermediate plots} are used to modify a previous plot. Only the last plot on which all low-level plotting changes have been made is shown.

It can be useful to show the intermediate plots, especially for teaching purposes. You can set the chunk option `fig.keep = 'low'`\index{chunk option!fig.keep} to keep low-level plotting changes. For example, Figure \@ref(fig:low-plots-1) and Figure \@ref(fig:low-plots-2) are from a single code chunk with the chunk option `fig.keep = 'low'`, although they appear to be from two code chunks. We also assigned different figure captions to them with the chunk option `fig.cap = c('A scatterplot ...', 'Adding a regression line...')`.\index{chunk option!fig.cap}

```{r, low-plots, fig.cap=c('A scatterplot of the cars data.', 'Adding a regression line to an existing scatterplot.'), fig.keep='low'}
par(mar = c(4, 4, .1, .1))
plot(cars)
fit = lm(dist ~ speed, data = cars)
abline(fit)
```

If you want to keep modifying a plot in a _different_ code chunk, please see Section \@ref(global-device).

## Customize the printing of objects in chunks (\*) {#opts-render}

By default, objects in code chunks are printed through the `knitr::knit_print()`\index{knitr!knit\_print()} function, which is by and large just `print()` in base R. The `knit_print()` function is an S3 generic function, which means you can extend it by yourself by registering S3 methods on it. The following is an example that shows how to automatically print data frames as tables via `knitr::kable()`:

`r import_example('print-method.Rmd')`

You can learn more about the `knit_print()` function in the **knitr** package\index{R package!knitr} vignette:

```{r, eval=FALSE}
vignette('knit_print', package = 'knitr')
```

The **printr** package\index{R package!printr} [@R-printr] has provided a few S3 methods to automatically print R objects as tables if possible. All you need is `library(printr)` in an R code chunk, and all methods will be automatically registered.

If you find this technique too advanced for you, some R Markdown output formats such as `html_document` and `pdf_document` also provide an option `df_print`, which allows you to customize the printing behavior of data frames. For example, if you want to print data frames as tables via `knitr::kable()`, you may set the option:

```yaml
---
output:
  html_document:
    df_print: kable
---
```

Please see the help pages of the output format functions (e.g., `?rmarkdown::html_document`) to determine whether an output format supports the `df_print` option and, if so, what the possible values are. 

In fact, you can completely replace the printing function `knit_print()` through the chunk option `render`, which can take any function to print objects. For example, if you want to print objects using the **pander** package\index{R package!pander}, you may set the chunk option `render` to the function `pander::pander()`:

````md
```{r, render=pander::pander}`r ''`
iris
```
````

The `render` option gives you complete freedom on how to print your R objects.

## Option hooks (\*) {#option-hooks}

Sometimes you may want to change certain chunk options\index{chunk option!option hooks}\index{option hooks} dynamically according to the values of other chunk options. You may use the object `opts_hooks` to set up an _option hook_ to do it. An option hook is a function associated with the option and to be executed when a corresponding chunk option is not `NULL`. This function takes the list of options for the current chunk as the input argument, and should return the (potentially modified) list. For example, we can tweak the `fig.width` option so that it is always no smaller than `fig.height`:

```{r, eval=FALSE}
knitr::opts_hooks$set(fig.width = function(options) {
  if (options$fig.width < options$fig.height) {
    options$fig.width = options$fig.height
  }
  options
})
```

Because `fig.width` will never be `NULL`, this hook function is always executed before a code chunk to update its chunk options. For the code chunk below, the actual value of `fig.width` will be 6 instead of the initial 5 if the above option hook has been set up:

````md
```{r fig.width = 5, fig.height = 6}`r ''`
plot(1:10)
```
````

As another example, we rewrite the last example in Section \@ref(opts-comment) so we can use a single chunk option `console = TRUE` to imply `comment = ""` and `prompt = TRUE`. Note that `console` is not a built-in **knitr** chunk option but a custom and arbitrary option name instead. Its default value will be `NULL`. Below is a full example:

````md
```{r, include=FALSE}`r ''`
knitr::opts_hooks$set(console = function(options) {
  if (isTRUE(options$console)) {
    options$comment <- ''; options$prompt <- TRUE
  }
  options
})
```

Default output:

```{r}`r ''`
1 + 1
if (TRUE) {
  2 + 2
}
```

Output with `console = TRUE`:

```{r, console=TRUE}`r ''`
1 + 1
if (TRUE) {
  2 + 2
}
```
````

The third example is about how to automatically add line numbers to any output blocks, including source code blocks, text output, messages, warnings, and errors. We have mentioned in Section \@ref(number-lines) how to use chunk options such as `attr.source` and `attr.output` to add line numbers. Here we want to use a single chunk option (`numberLines` in this example) to control the blocks to which we want to add line numbers.

```{r, eval=FALSE, tidy=FALSE}
knitr::opts_hooks$set(
  numberLines = function(options) {
    attrs <- paste0("attr.", options$numberLines)
    options[attrs] <- lapply(options[attrs], c, ".numberLines")
    options
  }
)

knitr::opts_chunk$set(
  numberLines = c(
    "source", "output", "message", "warning", "error"
  )
)
```

Basically, the option hook `numberLines` appends the attribute `.numberLines` to output blocks, and the chunk option `numberLines` set via `opts_chunk$set()` makes sure that the option hook will be executed.

With the above setup, you can use the chunk option `numberLines` on a code chunk to decide which of its output blocks will have line numbers, e.g., `numberLines = c('source', 'output')`. Specifying `numberLines = NULL` removes line numbers completely.

You may wonder how this approach differs from setting the chunk options directly, e.g., just `knitr::opts_chunk$set(attr.source = '.numberLines')` like we did in Section \@ref(number-lines). The advantage of using the option hooks here is that they only _append_ the attribute `.numberLines` to chunk options, which means they will not _override_ existing chunk option values, e.g., the source code block of the chunk below will be numbered (with the above setup), and the numbers start from the second line:

````md
```{r, attr.source='startFrom="2"'}`r ''`
# this comment line will not be numbered
1 + 1
```
````

It is equivalent to:

````md
```{r, attr.source=c('startFrom="2"', '.numberLines'}`r ''`
# this comment line will not be numbered
1 + 1
```
````
