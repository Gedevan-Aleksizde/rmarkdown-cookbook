# その他の言語 {#other-languages}

R Markdown は **knitr** を通して R 言語以外の多くのプログラミング言語をもサポートしています. 言語の名前は3連続のバッククオートの後のカーリーブレースの最初の単語で表現されます. 例えば ```` ```{r}```` の小文字の `r` はコードチャンクに R のコードが含まれていることを意味し, ```` ```{python}```` は Python のコードチャンクであることを表しています. この章ではあなたがあまり詳しくないであろういくつかの言語をお見せします.

**knitr** では, どの言語も言語エンジンを通してサポートされています. 言語エンジンは本質的にはソースコードとコードチャンクを入力として, 出力として文字列を返す関数です. これらは `knitr::knit_engines` オブジェクトで管理されています. 既存のエンジンはこのようにして確認すると良いでしょう.

```{r, eval=FALSE}
names(knitr::knit_engines$get())
```
```{r, echo=FALSE}
# bookdown によって登録されたエンジンを除外
engs = names(knitr::knit_engines$get())
i = match('theorem', engs)
if (!is.na(i)) engs = head(engs, i - 1)
engs
```

現時点では, R 言語でないほとんどの言語はコードチャンクごとに独立して実行されます. 例えば, 同じ文書内の `bash` コードチャンクは全てそれぞれ別々のセッションで実行されるため, 後の `bash` コードチャンクはそれ以前の `bash` チャンクで作成された変数を使うことができませんし, `cd` による作業ディレクトリの変更も異なる `bash` チャンク間で維持できません. R, Python, そして Julia のコードチャンクのみが同一セッションで実行されます. 全ての R コードチャンクは同一の R セッションで実行され, 全ての Python コードチャンクは同一の Python セッションされ……,  ということに注意してください. R セッションと Python セッションは2つの異なるセッションですが, 一方のセッションからもう一方のセッションのオブジェクトにアクセスしたり操作したりすることは可能です (\@ref(eng-python)節参照).

_R Markdown Definitive Guide_ [@rmarkdown2018] の  [Section 2.7](https://bookdown.org/yihui/rmarkdown/language-engines.html) では Python, シェル, SQL, Rcpp, Stan, JavaScript, CSS, Julia, C そして Fortran のコードを使用する例が紹介されています. この章ではさらなる言語エンジンを紹介します. そしてさらなる例はリポジトリ https://github.com/yihui/knitr-examples で見られます. "engine" という単語を含むファイルを探してください.

初めに, カスタム言語エンジンの登録によってこれがどのように動作するかを解明しましょう.

## カスタム言語エンジンを登録する (\*) {#custom-engine}

`knitr::knit_engines$set()`\index{knitr!knit\_engines} でカスタム言語エンジン\index{言語エンジン!カスタム}を登録できます. これは関数を入力として受け容れます. これが例です.

```{r, eval=FALSE}
knitr::knit_engines$set(foo = function(options) {
  # ソースコードは options$code にある
  # それを使ってやりたいことは何でもやろう
})
```

これは `foot` エンジンを登録し, ```` ```{foo}```` で始まるコードチャンクを使えるようになります.

エンジン関数は1つの引数 `options` を取り, これはコードチャンクのオプションのリストです. `options$code` にある文字列ベクトルとして, チャンクのソースコードにアクセスできます. 例えば, このコードチャンクに対して考えます.

````md
```{foo}`r ''`
1 + 1
2 + 2
```
````

`options` の `code` 要素は文字列ベクトル `c('1 + 1', '2 + 2')` になります.

言語エンジンは実はプログラミング言語として動作しなくてもよいですが, コードチャンクの任意のテキストを処理できます. まずは, コードチャンクの本文を大文字に変換するエンジンの例をお見せします.

```{r}
knitr::knit_engines$set(upper = function(options) {
  code <- paste(options$code, collapse = '\n')
  if (options$eval) toupper(code) else code
})
```

ポイントは `toupper` 関数を「コード」に適用して, `\n` でコードの全ての行を連結し, 単一の文字列として結果を返すことです. `toupper()` はチャンクオプション `eval = TRUE`\index{チャンクオプション!eval}の時にのみ適用され, そうでなければ元の文字列が返されることに注意してください.  このことは `eval` のようなチャンクオプションをエンジン関数内で利用する方法を示唆しています. 同様に, `results = 'hide'`\index{チャンクオプション!results} の時に出力を隠すため, 関数内に `if (options$results == 'hide') return()` を加えることも検討するとよいでしょう. 以下は `upper` エンジンをオプションとともに使用するチャンクの例です.

> ````md
> ```{upper}`r ''`
> Hello, **knitr** engines!
> ```
> ````
> 
> ```{upper}
> Hello, **knitr** engines!
> ```

次に, `py` という名前のもう1つの Python エンジン^[実用的には組み込みの `python` エンジンをを使うべきです. これは **reticulate** パッケージに基づいており, より良く Python コードチャンクをサポートしてくれます (\@ref(eng-python)節参照).]の例を紹介します. このエンジンは単純に R の `system2()` 関数から `python` コマンドを呼び出すことで実装しています.

```{r, tidy=FALSE}
knitr::knit_engines$set(py = function(options) {
  code <- paste(options$code, collapse = '\n')
  out  <- system2(
    'python', c('-c', shQuote(code)), stdout = TRUE
  )
  knitr::engine_output(options, code, out)
})
```

上記のエンジン関数を完全に理解するために, 以下を知っておく必要があります.

1. Python コードは文字列として与えられ (上記関数の `code`), コードはコマンドラインの呼び出し `python -c 'code'` によって実行できます. これが `system2()` のしていることです. `system2()` `stdout = TRUE` を指定することでテキスト出力を収集しています.

1. 最終的な出力を生成するため, チャンクオプション・ソースコード・テキスト出力を `knitr::engine_output()`\index{knitr!engine\_output()} 関数に与えることができます. この関数は `echo = FALSE` と `results = 'hide'` のようなよく使うオプションを処理します. よってあなたはこれらの場合に注意する必要はありません.

**knitr** の多くの言語エンジンはこのようにして定義されています. つまり `system2()` を使って言語に対応するコマンドを実行してます. もし技術的に詳しい話に興味があるなら, R ソースコードにはほとんどの言語エンジンが書かれているここ https://github.com/yihui/knitr/blob/master/R/engine.R を確認するとよいでしょう.

そして今や, 新しいエンジン `py` を使うことができます. 例えばこのように.

> ````md
> ```{py}`r ''`
> print(1 + 1)
> ```
> ````
> 
> ```{py, echo=FALSE}
> print(1 + 1)
> ```

あなたのバージョンの言語エンジンが **knitr**  の既存の言語エンジンよりも必要性がるか, より良いものだと確信しているなら, `knitr::knit_engines$set()` によって既存のものを上書きすることすらできます. たいていの場合は既存のエンジンに慣れたユーザーが驚いてしまうかもしれないので, そうすることはお薦めしませんが, どちらにせよこの可能性は頭の片隅に置いてほしいです.

## Python コードの実行と双方向処理 {#eng-python}

あなたが Python を好んでいることは知っていますので, とてもはっきりと言ってしまいましょう. R Markdown と **knitr** はなんと Python\index{言語エンジン!python}\index{Python} をサポートしています.

Python のコードチャンクを R Markdown 文書に加えるには チャンクヘッダ ``` ```{python}```` を使うことができます. 例えばこのように.

````md
```{python}`r ''`
print("Hello Python!")
```
````

いつもどおりにチャンクヘッダに `echo = FALSE` or `eval = FALSE` といったチャンクオプションを追加することができます. Python の **matplotlib** パッケージで描かれたグラフもサポートしています.

R Markdown と **knitr** の Python サポートは **reticulate** パッケージ\index{R パッケージ!reticulate} [@R-reticulate] に基づいており, このパッケージの重要な機能の1つは Python と R の双方向的なコミュニケーションを可能にすることです. 例えば **reticulate** の `py` オブジェクトを介して R セッションから Python の変数にアクセスしたり作成したりするとよいでしょう.

`r import_example('python.Rmd')`

**reticulate** パッケージに関する詳細は, https://rstudio.github.io/reticulate/ のドキュメントを見るとよいでしょう.

## `asis` エンジンでコンテンツを条件付きで実行する Execute content conditionally via the `asis` engine {#eng-asis}

その名が示すとおり, `asis` エンジン\index{言語エンジン!asis}はチャンクの内容をそのまま書き出します. このエンジンを使う利点は条件に応じてコンテンツを読み込めることです. つまりチャンクオプション `echo` によりチャンクの内容の表示を決定します. `echo = FALSE` の時はチャンクは隠されます. 以下は簡単な例です.

````md
```{r}`r ''`
getRandomNumber <- function() {
  sample(1:6, 1)
}
```

```{asis, echo = getRandomNumber() == 4}`r ''`
https://xkcd.com/221/ によれば, **真の**乱数を生成しました!
```
````

`asis` チャンク内のテキストは条件式 `getRandomNumber() == 4` が (ランダムに) 真であるならば表示されます.

## シェルスクリプトを実行する {#eng-bash}

あなたが好んでいるシェルに応じて, `bash` ・ `sh` ・ `zsh` エンジン\index{言語エンジン!bash}\index{言語エンジン!sh}\index{言語エンジン!zsh}でシェルスクリプトを実行できます. 以下はチャンクヘッダ ```` ```{bash}```` を使った `bash` の例です.

```{bash}
ls *.Rmd | head -n 5
```

`bash` は R の `system2()` 関数で呼び出されていることに注意してください. `~/.bash_profile` や `~/.bash_login` のようなプロファイルにある, あなたの定義したコマンドのエイリアスや `PATH` などの環境変数は無視されます. ターミナル上でシェルを使っている時のようにこれらのプロファイルがほしいなら, `engine.opts` を介して `-l` 引数を与えるとよいでしょう. これが例です.

````md
```{bash, engine.opts='-l'}`r ''`
echo $PATH
```
````

`-l` 引数を全ての `bash` チャンクで有効にしたいなら, 文書の冒頭でグローバルチャンクオプションに設定するとよいでしょう.

```{r, eval=FALSE}
knitr::opts_chunk$set(engine.opts = list(bash = '-l'))
```

チャンクオプション `engine.opts`\index{チャンクオプション!engine.opts} に文字列ベクトルとして他の引数を `bash` に与えることもできます.

## D3 で可視化する {#d3}

R のパッケージ **r2d3** [@R-r2d3]\index{R パッケージ!r2d3} は D3 可視化のインターフェースです. このパッケージは例えば Shiny のような他のアプリケーションと同様に R Markdown 文書内で使うことができます. R Markdown 内で使うにはコードチャンクで `r2d3()` 関数を呼び出すか, `d3` エンジンindex{言語!D3}\index{D3}\index{図!D3}を使用することができます. 後者は D3 ライブラリと Javascript の理解が要求されますが, それは本書で扱う範囲を超えますので, 読者自身による学習に任せます. 以下は `d3` エンジンで棒グラフを描く例です.

`r import_example('d3.Rmd')`

## `cat` エンジンでチャンクをファイルに書き出す {#eng-cat}

Sometimes it could be useful to write the content of a code chunk to an external file, and use this file later in other code chunks. Of course, you may do this via the R functions like `writeLines()`, but the problem is that when the content is relatively long, or contains special characters, the character string that you would pass to `writeLines()` may look awkward. Below is an example of writing a long character string to a file `my-file.txt`:

```{r, eval=FALSE}
writeLines("This is a long character string.
It has multiple lines. Remember to escape
double quotes \"\", but 'single quotes' are OK.
I hope you not to lose your sanity when thinking
about how many backslashes you need, e.g., is it
'\t' or '\\t' or '\\\\t'?",
con = "my-file.txt")
```

This problem has been greatly alleviated since R 4.0.0, because R started to support raw strings in `r"( )"` (see the help page `?Quotes`), and you do not need to remember all the rules about special characters. Even with raw strings, it can still be a little distracting for readers to see a long string written to a file explicitly in a code chunk.

The `cat` engine\index{language engine!cat} in **knitr** has provided a way for you to present text content in a code chunk and/or write it to an external file, without thinking about all the rules about R's character strings (e.g., you need double backslashes when you need a literal backslash).

To write the chunk content to a file, specify the file path in the chunk option `engine.opts`\index{chunk option!engine.opts}, e.g., `engine.opts = list(file = 'path/to/file')`. Under the hood, the list of values specified in `engine.opts` will be passed to the function `base::cat()`, and `file` is one of the arguments of `base::cat()`.

Next we will present three examples to illustrate the use of the `cat` engine.

### CSS ファイルに書き込む

As shown in Section \@ref(chunk-styling), you can embed a `css` code chunk in an Rmd document to style elements with CSS.\index{CSS}\index{language engine!css} An alternative way is to provide a custom CSS file to Pandoc via the `css` option of some R Markdown output formats such as `html_document`. The `cat` engine can be used to write this CSS file from Rmd.

This example below shows how to generate a file `custom.css` from a chunk in the
document, and pass the file path to the `css` option of the `html_document` format:

`r import_example("cat-css.Rmd")`

The only difference between the `css` code chunk approach and this approach is that the former approach writes the CSS code in place (i.e., in the place of the code chunk), which is inside the `<body>` tag of the output document, and the latter approach writes CSS to the `<head>` area of the output document. There will not be any practical visual differences in the output document.

### LaTeX コードをプリアンブルに含める

In Section \@ref(latex-preamble), we introduced how to add LaTeX code to the preamble, which requires an external `.tex` file. This file can also be generated from Rmd, and here is an example:

`r import_example("cat-latex.Rmd")`

In the LaTeX code in the `cat` code chunk above, we have defined the header and footer of the PDF document. If we also want to show the author name in the footer, we can append the author information to `preamble.tex` in another `cat` code chunk with options `engine.opts = list(file = 'preamble.tex', append = TRUE)` and `code = sprintf('\\fancyfoot[LO,RE]{%s}', rmarkdown::metadata$author)`. To understand how this works, recall that we mentioned earlier in this section that `engine.opts` is passed to `base::cat()` (so `append = TRUE` is passed to `cat()`), and you may understand the chunk option `code` by reading Section \@ref(option-code).

### YAML データをファイルに書き込みつつ表示する

By default, the content of the `cat` code chunk will not be displayed in the output document. If you also want to display it after writing it out, set the chunk option `class.source` to a language name. The language name is used for syntax highlighting. In the example below, we specify the language to be `yaml`:

````md
```{cat, engine.opts=list(file='demo.yml'), class.source='yaml'}`r ''`
a:
  aa: "something"
  bb: 1
b:
  aa: "something else"
  bb: 2
```
````

Its output is displayed below, and it also generated a file `demo.yml`.

```{cat, engine.opts=list(file='demo.yml'), class.source='yaml'}
a:
  aa: "something"
  bb: 1
b:
  aa: "something else"
  bb: 2
```

To show the file `demo.yml` is really generated, we can try to read it into R with the **yaml** package [@R-yaml]:

```{r}
xfun::tree(yaml::read_yaml('demo.yml'))
```

```{r, include=FALSE}
unlink('demo.yml')
```

## SAS コードを実行する {#eng-sas}

You may run SAS (https://www.sas.com) code using the `sas` engine\index{language engine!SAS}. You need to either make sure the SAS executable is in your environment variable `PATH`, or (if you do not know what `PATH` means) provide the full path to the SAS executable via the chunk option `engine.path`\index{chunk option!engine.path}, e.g., `engine.path = "C:\\Program Files\\SASHome\\x86\\SASFoundation\\9.3\\sas.exe"`. Below is an example to print out "Hello World":

````md
```{sas}`r ''`
data _null_;
put 'Hello, world!';
run;
```
````

## Stata コードを実行する {#eng-stata}

You can run Stata (https://www.stata.com) code with the `stata` engine\index{language engine!stata} if you have installed Stata. Unless the `stata` executable can be found via the environment variable `PATH`, you need to specify the full path to the executable via the chunk option `engine.path`\index{chunk option!engine.path}, e.g., `engine.path = "C:/Program Files (x86)/Stata15/StataSE-64.exe"`. The following is a quick example:

````md
```{stata}`r ''`
sysuse auto
summarize
```
````

The `stata` engine in **knitr** is quite limited. Doug Hemken has substantially extended it in the **Statamarkdown** package\index{R package!Statamarkdown}, which is available on GitHub at https://github.com/Hemken/Statamarkdown. You may find tutorials about this package by searching online for "Stata R Markdown."

## Asymptote でグラフィックを作成する {#eng-asy}

Asymptote (https://asymptote.sourceforge.io) is a powerful language for vector graphics. You may write and run Asymptote code in R Markdown with the `asy` engine\index{Asymptote}\index{language engine!asy} if you have installed Asymptote (see its website for instructions on the installation). Below is an example copied from the repository https://github.com/vectorgraphics/asymptote, and its output is shown in Figure \@ref(fig:elevation):

```{asy, elevation, fig.cap='A 3D graph made with Asymptote.', cache=TRUE, fig.retina=1, eval=is.na(Sys.getenv('CI', NA))}
import graph3;
import grid3;
import palette;
settings.prc = false;

currentprojection=orthographic(0.8,1,2);
size(500,400,IgnoreAspect);

real f(pair z) {return cos(2*pi*z.x)*sin(2*pi*z.y);}

surface s=surface(f,(-1/2,-1/2),(1/2,1/2),50,Spline);

surface S=planeproject(unitsquare3)*s;
S.colors(palette(s.map(zpart),Rainbow()));
draw(S,nolight);
draw(s,lightgray+opacity(0.7));

grid3(XYZgrid);
```

Note that for PDF output, you may need some additional LaTeX packages, otherwise you may get an error that looks like this:

```
! LaTeX Error: File `ocgbase.sty' not found.
```

If such an error occurs, please see Section \@ref(install-latex-pkgs) for how to install the missing LaTeX packages.

In the `asy` chunk above, we used the setting `settings.prc = false`. Without this setting, Asymptote generates an interactive 3D graph when the output format is PDF. However, the interactive graph can only be viewed in Acrobat Reader. If you use Acrobat Reader, you can interact with the graph. For example, you can rotate the 3D surface in Figure \@ref(fig:elevation) with your mouse.

### Generate data in R and read it in Asymptote

Now we show an example in which we first save data generated in R to a CSV file (below is an R code chunk):

```{r}
x = seq(0, 5, l = 100)
y = sin(x)
writeLines(paste(x, y, sep = ','), 'sine.csv')
```

Then read it in Asymptote, and draw a graph based on the data as shown in Figure \@ref(fig:sine-curve) (below is an `asy` code chunk):

```{asy, sine-curve, fig.cap='Pass data from R to Asymptote to draw a graph.', cache=TRUE, fig.retina=1, eval=is.na(Sys.getenv('CI', NA))}
import graph;
size(400,300,IgnoreAspect);
settings.prc = false;

// import data from csv file
file in=input("sine.csv").line().csv();
real[][] a=in.dimension(0,0);
a=transpose(a);

// generate a path
path rpath = graph(a[0],a[1]);
path lpath = (1,0)--(5,1);

// find intersection
pair pA=intersectionpoint(rpath,lpath);

// draw all
draw(rpath,red);
draw(lpath,dashed + blue);
dot("$\delta$",pA,NE);
xaxis("$x$",BottomTop,LeftTicks);
yaxis("$y$",LeftRight,RightTicks);
```

```{r, include=FALSE}
unlink('sine.csv')
```

## Style HTML pages with Sass/SCSS {#eng-sass}

Sass (https://sass-lang.com) is a CSS extension language\index{CSS!Sass}\index{Sass} that allows you to create CSS rules in much more flexible ways than you'd do with plain CSS. Please see its official documentation if you are interested in learning it.

The R package **sass** [@R-sass] \index{R package!sass}can be used to compile Sass to CSS. Based on the **sass** package, **knitr** includes two language engines: `sass`\index{language engine!sass} and `scss`\index{language engine!scss} (corresponding to the Sass and SCSS syntax, respectively) to compile code chunks to CSS. Below is a `scss` code chunk, with the chunk header ```` ```{scss}````:

```{scss}
$font-stack: "Comic Sans MS", cursive, sans-serif;
$primary-color: #00FF00;

.book.font-family-1 {
  font: 100% $font-stack;
  color: $primary-color;
}
```

You can also use the `sass` engine, and the Sass syntax is slightly different with the SCSS syntax, e.g.,

````md
```{sass}`r ''`
$font-stack: "Comic Sans MS", cursive, sans-serif
$primary-color: #00FF00

.book.font-family-1
  font: 100% $font-stack
  color: $primary-color
```
````

If you are reading [the HTML version of this section,](https://bookdown.org/yihui/rmarkdown-cookbook/eng-sass.html) you will notice that the font for this page has been changed to Comic Sans, which might be surprising, but please do not panic---[you are not having a stroke.](https://twitter.com/andrewheiss/status/1250438044542361600)

The `sass`/`scss` code chunks are compiled through the `sass::sass()` function. Currently you can customize the output style for the CSS code via the chunk option `engine.opts`, e.g., `engine.opts = list(style = "expanded")`. The default style is "compressed." If you are not sure what this means, please refer to the help page `?sass::sass_options` and look for the `output_style` argument.
