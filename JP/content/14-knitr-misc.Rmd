# その他の knitr のトリック {#knitr-misc}

チャンクオプション(\@ref(chunk-options)章)・出力フック(\@ref(output-hooks)章)・チャンクフック ( \@ref(chunk-hooks)章) にとどまらず, 他にも役に立つ関数やトリックが **knitr**\index{knitr}にはあります. この章では, コードチャンクの再利用, knit の早期終了, グラフの配置場所のカスタマイズの方法などといったトリックを紹介します.

## コードチャンクを再利用する {#reuse-chunks}

コードチャンク\index{コードチャンク}の再利用は, コピーアンドペーストなしで文書のどの場所でも自由にすることができます. ポイントはコードチャンクにラベルを付けることで, そうすると他の場所でラベルによって参照することができます. コードチャンクの再利用\index{コードチャンク!再利用}には3種類の方法があります.

### チャンクを別の場所にも埋め込む (\*) {#embed-chunk}

あるコードチャンクを別の場所で, そのラベルを `<<>>`\index{コードチャンク!埋め込み}\index{コードチャンク!<<>>} で囲むことで埋め込めます. すると **knitr** は自動的に `<<ラベル>>` を実際のコードへと展開してくれます. 例えば, この方法で R 関数を作ることができます.

````md
華氏温度を摂氏温度に変換する関数を定義する

```{r, f2c}`r ''`
F2C <- function(x) {
  <<check-arg>>
  <<convert>>
}
```

最初に入力値が数値か確認する

```{r, check-arg, eval=FALSE}`r ''`
  if (!is.numeric(x)) stop("入力は数値でなければなりません!")
```

それから実際に変換します

```{r, convert, eval=FALSE}`r ''`
  (x - 32) * 5/ 9
```
````

これはドナルド=クヌースの提案する[文芸プログラミング](https://en.wikipedia.org/wiki/Literate_programming) の主要なアイディアの1つに基づいたものです. この技術の利点は (複雑な) コードを小さな部品に分割し, 別々のコードチャンクに書き, 文脈の中で説明することができる点です. 全ての部品は実行される主要なコードチャンクで構成することができます.

上記の例に対して, `f2c` というラベルのある最初のコードチャンクはこうなります.

````md
```{r, f2c}`r ''`
F2C <- function(x) {
  if (!is.numeric(x)) stop("The input must be numeric!")
  (x - 32) * 5/ 9
}
```
````

1つのコードチャンクに好きな数のコードチャンクを埋め込むことが可能です. 埋め込みは再帰的にすることも可能です. 例えば, チャンク A をチャンク B に埋め込み, さらにチャンク B をチャンク C に埋め込むこともできます. チャンク C はチャンク B から読み込まれたチャンク A を含むことになります. 

マーカー `<<ラベル>>` は独立した行に置く必要はありません. コードチャンクのどこにでも埋め込むことができます.

### 別のチャンクで同一のチャンクラベルを使う {#same-label}

完全に同じコードを2回異常使いたいならば, ラベル付きのチャンクを定義し, そして同じラベルであるものの中身が空のチャンクを作ることもできます. 例えばこのように.

````md
これは評価されないコードチャンクです

```{r, chunk-one, eval=FALSE}`r ''`
1 + 1
2 + 2
```

実際に評価されるのはここです

```{r, chunk-one, eval=TRUE}`r ''`
```
````

上記の例でチャンクラベル "chunk-one" を2度使い, 2度目のチャンクは最初のチャンクの単なる再利用です.

グラフかあるいは他のファイルを生成するのに, この方法で複数回コードチャンクを実行するのはお薦めしません. 最後のチャンクで作成された画像ファイルがそれ以前のものを上書きするかもしれないからです. これらのチャンクのうち1つだけにチャンクオプション `eval = TRUE` を使い, それ以外では `eval =FALSE` を使うのならば大丈夫です.

### 参照ラベルを使う (\*) {#ref-label}

チャンクオプション `ref.label`\index{チャンクオプション!ref.label} はチャンクの中身を取得するために, そのチャンクラベルのベクトルを取ります. 例えば以下の `chunk-a` というラベルのコードチャンクは `chunk-c` と `chunk-b` を結合したものです.

````md
```{r chunk-a, ref.label=c('chunk-c', 'chunk-b')}`r ''`
```

```{r chunk-b}`r ''`
# これはチャンク b
1 + 1
```

```{r chunk-c}`r ''`
# これはチャンク c
2 + 2
```
````

言い換えるなら, `chunk-a` は本質的にこうなります.

````md
```{r chunk-a}`r ''`
# これはチャンク c
2 + 2
# これはチャンク b
1 + 1
```
````

チャンクオプション `ref.label` は, コピーアンドペーストを使うことなくコードチャンクを再構成する, とても柔軟な方法を提供しています. 参照先のコードチャンクが `ref.label` が使われたチャンクの前にあるか, 後にあるかは問題になりません. 先に書かれたコードチャンクは後のコードチャンクを参照できます.

\@ref(code-appendix)節にはこのチャンクオプションの応用例があります.

## オブジェクトが作られる前に使用する (\*) {#load-cache}

コードチャンクとインライン R コードを含む **knitr** 文書内の全てのコードは, 始点から終点まで順番に実行されます. 理論上は, 値が代入される前の変数を使うことができません. しかしいくつかの場合では, 文書内で変数の値により早く言及したいことがあるかもしれません. 例えば結果を論文の概要に掲載したいというのはよくある状況ですが, 結果は実際には文書のもっと後で計算されます. 以下の例はそのアイディアを具体化したものですが, 実行はできません.

````md
---
title: 重要なレポート
概要: >
  この分析では `x` の平均値が
  `r knitr::inline_expr('mx')` であった.
---

我々は次のチャンクで `mx` を作成した.

```{r}`r ''`
x <- 1:100
mx <- mean(x)
```
````

この問題を解決するには, オブジェクトの値がどこかに保存され, 文書が次回コンパイルされる時に読み込まれなければなりません. これは, 文書が最低でも2回コンパイルされなければならないという意味であることに注意してください. 以下は `saveRDS()` 関数を使った, 実行可能な解決策の1つです.

````md
```{r, include=FALSE}`r ''`
mx <- if (file.exists('mean.rds')) {
  readRDS('mean.rds')
} else {
  "`mx` の値はまだ利用できない"
}
```

---
title: 重要なレポート
概要: >
  この分析では `x` の平均値が
  `r knitr::inline_expr('mx')` であった.
---

我々は次のチャンクで `mx` を作成した.

```{r}`r ''`
x <- 1:100
mx <- mean(x)
saveRDS(mx, 'mean.rds')
```
````

最初のコンパイルでは, 概要に「`mx` の値はまだ利用できない」という文言が現れます. その後, もう1度コンパイルすると `mx` の値が現れます.

`knitr::load_cache()`\index{knitr!load\_cache()} 関数はもう1つの解決策で, キャッシュ\index{キャッシュ}済みの特定のコードチャンクからオブジェクトの値を読み込むことが可能になります. このアイディアは上記の例と似ていますが, オブジェクトが自動でキャッシュデータベースに保存されるため,  オブジェクトを手動で保存して読み込む手間を省くことになります. あなたがする必要があるのは `load_cache()` で読み込むことだけになります. 以下は単純化した例です.

````md
---
title: An important report
abstract: >
  この分析では `x` の平均値が
  `r knitr::inline_expr("knitr::load_cache('mean-x', 'mx')")` であった.
---

我々は次のチャンクで `mx` を作成した.

```{r mean-x, cache=TRUE}`r ''`
x <- 1:100
mx <- mean(x)
```
````

この例ではチャンクラベル `mean-x` をコードチャンクに追加し, これは `load_cache()` 関数に与えられています. そしてチャンクオプション `cache = TRUE`\index{チャンクオプション!cache} でチャンクはキャッシュされています. このコードチャンクの全てのオブジェクトはキャッシュデータベースに保存されます. 繰り返しになりますが, この文書を最低でも2回コンパイルしなければならず. よってオブジェクト `mx` はキャッシュデータベースから正しく読み込まれます. `mx` の値が将来も変更される予定がないなら, 文書をこれ以上コンパイルする必要はありません.

もし `load_cache()` の第2引数でオブジェクト名を指定しないなら, キャッシュデータベース全体が現在の環境に読み込まれます. 文書の後方でオブジェクトが作成される前に, キャッシュデータベースにあるものならどれでも使うことができます. これが例です.


```{r, eval=FALSE}
knitr::load_cache('mean-x')
x   # the object `x`
mx  # the object `mx`
```

## knit 処理を打ち切る {#knit-exit}

時には knit 処理を文書の末尾よりも早い時点で終了したいかもしれません. 例えば何か分析する作業をしていて, 結果の前半だけを共有したいとか, まだ一番最後のコードが終了していないということがあるかもしれません. このような状況ではコードチャンクで `knit_exit()`\index{knitr!knit\_exit()} 関数を使うことができます. この関数はそのチャンクの直後で knit 処理を終わらせることができます.

以下は単純な例です. ここではとても単純なチャンクと, その後にもっと時間のかかるチャンクを配置しています.

````md
```{r}`r ''`
1 + 1
knitr::knit_exit()
```

あなたは出力のうち上記のコンテンツだけを見たい.

```{r}`r ''`
Sys.sleep(100)
```
````

通常ならば100秒待たなければなりませんが, `knit_exit()` を呼び出しているので文書の残りの部分は無視されます.

## どこにでもグラフを生成し, 表示させる {#fig-chunk}

グラフは通常コードチャンク内で生成され, その直下に表示されますが, どこに表示するかを好きに指定することも, コードチャンクに隠すこともできます. 以下はその例です.

````md
このコードチャンクでグラフを生成しますが, 表示はしません.

```{r cars-plot, dev='png', fig.show='hide'}`r ''`
plot(cars)
```

別の段落でグラフを導入します

![A nice plot.](`r knitr::inline_expr("knitr::fig_chunk('cars-plot', 'png')")`)
````

コードチャンクでは, 一時的にグラフを隠すためにチャンクオプション `fig.show='hide'`\index{チャンクオプション!fig.show} を使用しました. それから別の段落でこのグラフ画像のファイルパスを取得するために `knitr::fig_chunk()`\index{knitr!fig\_chunk()} 関数を呼び出しました. このパスは普通は `test_files/figure-html/cars-plot-1.png` のようになっています. `fig_chunk()` 関数にはこのファイルパスを導出するためにチャンクラベルとグラフィックデバイス名を与える必要があります.

**blogdown** で作成したウェブサイトへの `fig_chunk()` の応用を https://stackoverflow.com/a/46305297/559676 で見ることもできます. この関数はどの R Markdown 出力フォーマットでも動作します. 特にスライド上では, スクリーンの広さが限られているため, 画像を表示するのに便利でしょう. 1つのスライドでコードを提示し, さらに別のスライドで画像を表示させることもできます.

## 以前のコードチャンクのグラフを修正する {#global-device}

 **knitr** はデフォルトでは, コードチャンクごとに新規にグラフィックデバイスを開いてグラフを記録しています. これは1つ問題を起こしています. グラフィックデバイスが既に閉じられているため, 以前のコードチャンクで作成されたグラフを簡単には修正できないという問題です. base グラフィックにとって, これはたいていの場合で問題となります. なお **ggplot2** [@R-ggplot2] のような grid ベースのグラフィックは, グラフを R オブジェクトとして保存できるので当てはまりません. 例えばあるコードチャンクでグラフを描き, 後でグラフに線を描き足したいなら, R は高水準グラフがまだ作られていないというエラーを示すので, 線を描き足すことができません.

全てのコードチャンクでグラフィックデバイスを開いたままにしたいなら, 文書の冒頭で **knitr** パッケージのオプションである \index{knitr!opts\_knit}\index{knitr!global.device}\index{図!グローバル} を設定します.

```{r, eval=FALSE}
knitr::opts_knit$set(global.device = TRUE)
```

より頻繁に使われる `opts_chunk` ではなく `opts_knit` が使われていることに注意してください. 例は Stack Overflow の https://stackoverflow.com/q/17502050 という投稿で見ることもできます.

グローバルなグラフィックデバイスを必要としなくなった時は, オプションを `FALSE` に設定できます. これは完全な例です.

`r import_example('global-device.Rmd')`

## グループ化したチャンクオプションを保存し再利用する (\*) {#opts-template}

いくつかのチャンクオプションを頻繁に使うのなら, それらを1つのグループ\index{チャンクオプション!オプションのテンプレート}\index{テンプレート!チャンクオプション}として保存し, 以降はグループ名を書くだけで再利用できるようにするとよいかもしれません. これは `knitr::opts_template$set(name = list(options))`\index{knitr!opts\_template} で実行できます.  それからこのグループ名をチャンクオプション `opts.label`\index{チャンクオプション!opts.label} で参照することで使用できます. 例えばこのように.

````md
```{r, setup, include=FALSE}`r ''`
knitr::opts_template$set(fullwidth = list(
  fig.width = 10, fig.height = 6,
  fig.retina = 2, out.width = '100%'
))
```

```{r, opts.label='fullwidth'}`r ''`
plot(cars)
```
````

`opts.label = 'fullwidth'` とすると, **knitr** は knitr::opts_template` から一連のチャンクオプションを読み込み, 現在のチャンクに適用します. これはタイピングの労力を削減できます. チャンクオプションを文書全体で使用しなければならないならば, グローバルに設定すべきでしょう (\@ref(chunk-options)章参照).

`opts.label` から読み込んだオプションを上書きすることもできます. 例えば以下のチャンクで `fig.height = 7` を設定したなら, 実際の値は `6` でなく `7` になります.

````md
```{r, opts.label='fullwidth', fig.height=7}`r ''`
plot(cars)
```
````

オプションのグループは好きな数だけ保存できます. 例えば `knitr::opts_template$set(group1 = list(...), group2 = list(...))` のように.

## Rmd ソースの生成に `knitr::knit_expand()` を使う {#knit-expand}

`knitr::knit_expand()`\index{knitr!knit\_expand()} 関数はデフォルトでは `{{ }}` 内の表現を値に展開 (expand) します. これが例です.

```{r, tidy=FALSE, collapse=TRUE}
knitr::knit_expand(text = "`pi` の値は {{pi}} である.")
knitr::knit_expand(
  text = "`a` の値は {{a}} なので, `a + 1` は {{a+1}} である.",
  a = round(rnorm(1), 4)
)
```

`{{ }}` 内に動的なものが含まれている Rmd 文書であれば, `knit_expand()` を適用して `knit()` を呼び出してコンパイルすることができるということを, この例は意味しています. 例えばここに `template.Rmd` という文書があったとします.

````md
# {{i}} に対する回帰

```{r lm-{{i}}}`r ''`
lm(mpg ~ {{i}}, data = mtcars)
```
````

`mtcars` データセット内で, `mpg` に対して他の全ての変数を一つ一つ使用した線型回帰モデルを構築できます.

````md
```{r, echo=FALSE, results='asis'}`r ''`
src = lapply(setdiff(names(mtcars), 'mpg'), function(i) {
  knitr::knit_expand('template.Rmd')
})
res = knitr::knit_child(text = unlist(src), quiet = TRUE)
cat(res, sep = '\n')
```
````

この例が難しくて理解できないと感じたら, チャンクオプション `results = 'asis'`\index{チャンクオプション!results} の意味を知るのに\@ref(results-asis)節を, `knitr::knit_child()`\index{knitr!knit\_child()} の使用法を知るのに\@ref(child-document)節を見てください.

## コードチャンクにラベルの重複を許可する (\*) {#duplicate-label}

<!-- https://stackoverflow.com/questions/36868287/purl-within-knit-duplicate-label-error/47065392#47065392 -->

**knitr** はデフォルトでは文書内でチャンクラベルが重複することを許可しません. 重複するラベルは文書を knit する際にエラーを引き起こします. これは文書内でコードチャンクをコピーアンドペーストするときに最もよく起こります. あなたもこのようなエラーメッセージにでくわしたことがあるかもしれません.

```text
processing file: myfile.Rmd
Error in parse_block(g[-1], g[1], params.src, markdown_mode) :
  Duplicate chunk label 'cars'
Calls: <Anonymous> ... process_file -> split_file -> lapply ->
  FUN -> parse_block
Execution halted
```

しかし, 今回のお話は重複するラベルを許可したいというものです. 例えば親文書 `parent.Rmd` があり, その中で子文書を複数回 knit するならば, 失敗するでしょう.

```{r, eval = FALSE}
# 設定
settings = list(...)

# 1度目の実行
knit_child('useful_analysis.Rmd')

# 新しい設定
settings = list(...)

# 再実行
knit_child('useful_analysis.Rmd')
```

この筋書きでは, 子文書が knit される**前に** R のグローバルオプションを設定することでラベルの重複を許可できます\index{knitr!knitr.duplicate.label}.

```{r, eval = FALSE}
options(knitr.duplicate.label = 'allow')
```

子文書ではなくメインの文書でラベルの重複を許可したいなら, `knitr::knit()` が呼び出される**前に**設定しなければなりません. それを実現する可能性の1つとして, `~/.Rprofile` ファイル内で設定するという方法があります (詳細は `?Rprofile` のヘルプを見てください).

このオプションの設定は注意深くすべきです. ほとんどのエラーメッセージと同様に, なんらかの理由があってこれらのエラーが存在します. 重複するチャンクを許可することは図や相互参照に関して暗黙の問題を生み出す可能性があります. 例えば, グラフ画像のファイル名はチャンクラベルによって決まるので, 2つのコードチャンクが同じラベルを持ち, かつ両方のチャンクが図を生成しているなら, 理論上はこれらの画像ファイルは互いに上書きすることになります (そしてエラーも警告も発しません). `knitr.duplicate.label = "allow"` オプションがあると, **knitr** は重複するラベルに暗黙に数字の接頭語を追加して変更してしまいます. 例えば, 2つのコードチャンクに対してはこうなります.

````md
```{r, test}`r ''`
plot(1:10)
```

```{r, test}`r ''`
plot(10:1)
```
````

2つ目のラベルは暗黙のうちに `test-1` に変更されます. これはラベル `test` のチャンクからのグラフ画像を上書きすることを回避するかもしれませんが, 同時にチャンクラベルが予想に反したものになります. ゆえに, 相互参照がチャンクラベルに基づいているため, 図の相互参照\index{相互参照} (\@ref(cross-ref)節参照) が難しくなるかもしれません.

## より透明性のあるキャッシュの仕組み {#cache-rds}

\@ref(cache)節で紹介した **knitr** のキャッシュの仕組みが複雑すぎると思ったら (実際そうです!), `xfun::cache_rds()`\index{xfun!cache\_rds()} 関数に基づいた, より簡単なキャッシュの仕組み\index{キャッシュ}を検討するとよいかもしれません. これが例です.

```{r, eval=FALSE}
xfun::cache_rds({
  # ここに時間のかかるコードを書く
})
```

**knitr** のキャッシュの難解なのは, キャッシュの無効化のタイミングがどう決定されるかという点です. `xfun::cache_rds()` にとっては, これはずっと明確です. この関数を最初に R コードに与えたとき, コードが評価され, 結果が `.rds` ファイルに保存されます. 次に `cache_rds()` を再実行すると, `.rds` ファイルを読み込み, コードを再び評価することなく直ちに結果を返します. キャッシュを無効化する最も明確な方法は, `.rds` ファイルを削除することです. 手動で削除したくないなら, `xfun::cache_rds()` に `return = TRUE` 引数を付けて呼び出すこともできます.

**knitr** のソース文書上のコードチャンクで `xfun::cache_rds()` が呼び出された時, `.rds` ファイルのパスはチャンクオプション `cache.path`\index{チャンクオプション!cache.path} とチャンクラベルによって決定します. 例えば `input.Rmd` という Rmd 文書に `foo` というチャンクラベルのあるコードチャンクがあるとします.

````md
```{r, foo}`r ''`
res <- xfun::cache_rds({
  Sys.sleep(3)
  1:10
})
```
````

`.rds` ファイルのパスは `input_cache/FORMAT/foo_HASH.rds` という形式になります. ここで  `FORMAT` は Pandoc の出力フォーマット名 (例えば `html` あるいは `latex`) であり, `HASH` は a-z および 0-9 からなる32桁の16進 MD5 ハッシュ値です. 例えば `input_cache/html/foo_7a3f22c4309d400eff95de0e8bddac71.rds` のようになります.

`?xfun::cache_rds` のヘルプで言及されているように, キャッシュを無効化したいであろう2つのよくあるケースがあります. (1) 評価式が変更された時, (2) 評価式の外部の変数が使用され, その変数の値が変更された時です. 次に, この2つのキャッシュ無効化の方法がどう動作するのかと, 異なるコードのバージョンに対応する複数のキャッシュのコピーをどう保持するかを説明します.

### コードの変更によってキャッシュを無効化する

例えば `cache_rds({x + 1})` から `cache_rds({x + 2})` へと, `cache_rds()` 内のコードを変更したとき, キャッシュは自動で無効化され, コードは再評価されます. しかし, 空白やコメントの変更は問われないことに注意してください. あるいは一般論として, パースされた表現に影響のない範囲の変更ではキャッシュは無効化されません. 例えば以下の2つの `cache_rds()` でパースされたコードは本質的に同等です.

```r
res <- xfun::cache_rds({
  Sys.sleep(3  );
  x<-1:10;  # セミコロンは問題ではない
  x+1;
})

res <- xfun::cache_rds({
  Sys.sleep(3)
  x <- 1:10  # これはコメント
  x +
    1  # 空白の変更は完全に自由
})
```

つまり, 最初のコードを `cache_rds()` で実行したなら, 2度目のコードはキャッシュの利点を得ることが可能です. この性質はキャッシュを無効化することなくコードの見た目を整える変更が可能になるため, 便利です.

2つのバージョンのコードが同等であるか自信がないなら, 以下のように `parse_code()` を試すこともできます.

```{r, tidy=FALSE}
parse_code <- function(expr) {
  deparse(substitute(expr))
}
# 空白とセミコロンは関係ない
parse_code({x+1})
parse_code({ x   +    1; })
# 左アロー演算子と右アロー演算子は同じ
identical(parse_code({x <- 1}), parse_code({1 -> x}))
```

### グローバル変数の変更によってキャッシュを無効化する

変数にはグローバルとローカル変数の2種類があります. グローバル変数は評価式の外部で作られ, ローカル変数は評価式の内部で作られます. 評価式内のグローバル変数の値が変われば, キャッシュされた結果は, もはや再度実行して得られる結果を反映しません. 例えば以下の評価式で, `y` が変化したなら, あなたが一番やりたいのはきっと, キャッシュを無効化して評価をやり直すことでしょう. さもなければ古い `y` の値を維持したままになってしまいます.

```r
y <- 2

res <- xfun::cache_rds({
  x <- 1:10
  x + y
})
```

`y` が変化した時にキャッシュを無効化\index{キャッシュ!無効化}するには,  キャッシュを無効化すべきかを決定する際に `y` も考慮する必要があることを, `hash` 引数を通して `cache_rds()` に教えてあげることもできます.

```r
res <- xfun::cache_rds({
  x <- 1:10
  x + y
}, hash = list(y))
```

`hash` 引数の値が変化した時, 前述のキャッシュファイル名に含まれる32桁のハッシュ値も対応して変化するため, キャッシュは無効化されます. これで他の R オブジェクトとキャッシュの依存関係を指定する手段を得ました. 例えば R のバージョンに依存してキャッシュを取りたいなら, このようにして依存関係を指定することもできます.

```r
res <- xfun::cache_rds({
  x <- 1:10
  x + y
}, hash = list(y, getRversion()))
```

あるいはデータファイルが最後に修正されたタイミングに依存させたいなら, こうします.

```r
res <- xfun::cache_rds({
  x <- read.csv("data.csv")
  x[[1]] + y
}, hash = list(y, file.mtime("data.csv")))
```

`hash` 引数にこのグローバル変数のリストを与えたくないなら, 代わりに `hash = "auto"` を試すこともできます. これは全てのグローバル変数を自動的に把握し, それらの値のリストを `hash` 引数の値に使用することを試みるよう `cache_rds()` に指示するものです.

```r
res <- xfun::cache_rds({
  x <- 1:10
  x + y + z  # y と z はグローバル変数
}, hash = "auto")
```

これは以下と同等です.

```r
res <- xfun::cache_rds({
  x <- 1:10
  x + y + z  # y と z はグローバル変数
}, hash = list(y = y, z = z))
```

`hash = "auto"` とした時, グローバル変数は `codetools::findGlobals()` によって識別されます. これは完全に信頼できるものではないかもしれません. あなたのコードを一番良く知っているのはあなた自身ですので, どの変数がキャッシュを無効化できるかを万全にしたいならば, `hash` 引数には明示的に値のリストを指定することをお薦めします.

### キャッシュの複数のコピーを保持する

キャッシュは典型的には時間のかかるコードに対して使用されるので, たぶんあなたは無効化することに対して躊躇するべきでしょう. キャッシュを無効化するのが早すぎたり, 積極的すぎたりしたことを後悔するかもしれません. もし古いバージョンのキャッシュが再び必要になったら, 再現のために長い計算時間を待たなければなりませんから.

`cache_rds()` の `clean` 引数\index{キャッシュ!clean}を `FALSE` に設定すれば, キャッシュの古いコピーを保持することが可能になります. この挙動を R セッション全体を通してデフォルトにしたいなら, R のグローバルオプション `options(xfun.cache_rds.clean = FALSE)` で設定することもできます. デフォルトでは, `clean = TRUE` と `cache_rds()` は毎回, 古いキャッシュを削除しようと試みます. `clean = FALSE` の設定は, あなたがまだ試験的なコードを使用しているなら有用になりえます. 例えば, 2つのバージョンの線形モデルのキャッシュを取ることができます.

```{r, eval=FALSE}
model <- xfun::cache_rds({
  lm(dist ~ speed, data = cars)
}, clean = FALSE)

model <- xfun::cache_rds({
  lm(dist ~ speed + I(speed^2), data = cars)
}, clean = FALSE)
```

どちらのモデルを使うかを決めたら, `clean = TRUE` を再度設定するか, この引数を消すことでデフォルトの `TRUE` に戻すことができます.

### **knitr** のキャッシュ機能との比較

**knitr** キャッシュ, つまりチャンクオプション `cache = TRUE` をいつ使うべきか, そして `xfun::cache_rds()` をいつ使うべきか迷うかもしれません. `xfun::cache_rds()` の大きな利点は副作用のキャッシュを取らず, 評価式の値のみであることです. その一方で **knitr** は副作用についてもキャッシュを取ります. 出力やグラフを表示するといった副作用のいくつかは有用かもしれません. 例えば以下のコードでは, `cache_rds()` が次回にキャッシュを読み込んだ時, テキスト出力とグラフが失われてしまい, `1:10` という値だけが戻ってきます.

```{r, eval=FALSE}
xfun::cache_rds({
  print("Hello world!")
  plot(cars)
  1:10
})
```

これと比較してオプション `cache = TRUE` のあるコードチャンクでは, 全てがキャッシュされます.

````md
```{r, cache=TRUE}`r ''`
print("Hello world!")
plot(cars)
1:10
```
````

**knitr** のキャッシュ機能の大きな利点であると同時にユーザーが最もよく不満の対象とする点は, キャッシュがとても多くの要因で決まるため, うっかり無効化してしまうかもしれないという点です. 例えば, チャンクオプションのいかなる変更もキャッシュを無効化する可能性がありますが,^[これはデフォルトの挙動であり, 変更することができます. 全てのチャンクオプションがキャッシュに影響しないよう, より細かい粒度でキャッシュを取るようにできるようなるには, https://gedevan-aleksizde.github.io/knitr-doc-ja/cache.html をご覧ください.] 計算に影響しないであろうチャンクオプションもあります. 以下のコードチャンクでは, チャンクオプション `fig.width = 6` を `fig.width = 10` へと変更することはキャッシュを無意味なものにしませんが, 無効化してしまいます.

````md
```{r, cache=TRUE, fig.width=6}`r ''`
# there are no plots in this chunk
x <- rnorm(1000)
mean(x)
```
````

実際のところ **knitr** のキャッシュはかなり強力で柔軟であり, 多くの方法で挙動を調整できます. あなたはキャシュがどう動作するのかを学び理解するのに, 最終的に計算するタスクの所要時間よりもはるかに多くの時間を費やしてしまうかもしれません. ですので私はパッケージの作者として, これらのあまり知られていない機能は紹介するに値するのかと, しばしば疑問に思っています.

まだはっきりわからない人は, `xfun::cache_rds()` は計算のキャッシュを取るために一般的な方法でなおかつどこでも動作し, 一方で **knitr** のキャッシュは **knitr** 文書でのみ動作すると覚えてください.
