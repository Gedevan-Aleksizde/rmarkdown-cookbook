# 出力フック (\*) {#output-hooks}

**knitr** パッケージによって, あなたはコードチャンクから出力されるものを各パーツ, ソースコード・テキスト出力・メッセージ・グラフといったものごとに制御しています. この制御は「出力フック」\index{出力フック}\index{output hooks|see{出力フック}} (output hook(s))によって実現されています. 出力フックは出力の各パーツを入力 (典型的には文字列ベクトルとして扱います) とし, 文字列を出力文書に書き出すために返す一連の関数です. 現時点ではこのしくみを理解するのは簡単ではないでしょうが, これから説明する簡単な例を見ればこのアイディアがはっきりと理解できるものと思います. この例ではコードチャンクの出力が **knitr** の出力フックを介してレンダリングされる様子を表しています.

このような1行だけのコードチャンクについて考えてみてください.

````md
```{r}`r ''`
1 + 1
```
````

**knitr** がコードチャンクを評価すると, 2つの出力要素を得ます. 2つとも文字列ベクトルとして保持されます. ソースコードの `"1 + 1"` と, テキスト出力の `"[1] 2"` です. これらの文字列は求められている出力フォーマットに応じて, チャンクフックによってさらなる処理がなされます. たとえば Markdown 文書では **knitr** はソースコードに言語名を付けてコードブロックで囲みます. これは `source` フックを介して行われ, だいたいこのような関数となります.

```{r, eval=FALSE}
# 上記のケースでは, `x` は文字列 "1 + 1" に相当
function(x, options) {
  # ここの小文字 "r" は言語名を表す
  paste(c('```r', x, '```'), collapse = '\n')
}
```

同様に, テキスト出力はこのような `output` フック関数によって処理されます.

```{r, eval=FALSE}
function(x, options) {
  paste(c('```', x, '```'), collapse = '\n')
}
```

よって上記のコードチャンクの最終的な出力はこのようになります.

````md
```r
1 + 1
```

```
[1] 2
```
````

実際のフックは上記のような2つの関数よりも複雑ですが, 発想は同じです. `knit_hooks`\index{knitr!knit\_hooks} オブジェクトから `get()` メソッドで実際のフック関数を取得できます. これが例です.

```{r, eval=FALSE}
# 意味のある出力のため, 以下のコードは
# knitr 文書のコードチャンクの *内部で* 実行されるべき
knitr::knit_hooks$get('source')
knitr::knit_hooks$get('output')
# または knitr::knit_hooks$get(c('source', 'output'))
```

**knitr** パッケージの開発に貢献することに本当に関心がない方には, 組み込みのフック関数のソースコードを読むことをお薦めしません. 関心がある方は, このコードは https://github.com/yihui/knitr/tree/master/R にある `hooks-*.R` という形式で命名されたスクリプトファイルでご覧ください. 例えば `hooks-md.R` には R Markdown 文書に対するフックが含まれています. 普通であれば **knitr** ユーザーにとっては, 組み込みのフックを活かして使うカスタム出力フックの作り方を知っていれば十分です. この章ではそれが学べますし, 以下では基本的な考え方を示します.

カスタム出力フックは `knit_hooks` の `set()` メソッドによって登録されます. このメソッドは既存のデフォルトのフックを上書きするので, 既存のフックのコピーを保存し, 好きなように出力要素を処理して, その結果をこのデフォルトのフックに与えるようにしておくことをお薦めします. 構文はたいてい次のようになります.

```{r, eval=FALSE}
# ここで local() を使うかは任意 (ここでは単に `hook_old` のような不要なグローバル変数を作ることを避ける目的)
local({
  hook_old = knitr::knit_hooks$get('NAME')  # 古いフックを保存する
  knitr::knit_hooks$set(NAME = function(x, options) {
    # ここで, x に何らかの処理を行い, それから 
    # 新しい x を古いフックに与える
    hook_old(x, options)
  })
})
```

ここで, `NAME` は以下のいずれかのフックの名前を意味します.

- `source`: ソースコードを処理するフック.

- `output`: テキスト出力を処理するフック.

- `warning`: 警告 (たいていは `warning()` で発生するもの) を処理するフック.

- `message`: メッセージ (たいていは `message()` で発生するもの) を処理するフック.

- `error`: エラーメッセージ (たいていは `stop()` で発生するもの) を処理するフック.

- `plot`: グラフのファイルパスを処理するフック.

- `inline`: インライン R コードからの出力を処理するフック.

- `chunk`: チャンク全体の出力を処理するフック.

- `document`: 文書全体を処理するフック.

フック関数の引数 `x` の意味は上記のリストで説明されています. `options` 引数は現在のコードチャンクのオプションのリストを意味します. 例えば `foo = TRUE` と設定したなら, フック関数内では `options$foo` でこの値を得ることができます. `options` 引数は `inline` および `document` フックでは利用できません.

出力フックによって, チャンクと文書の出力の部品1つ1つに対して究極のコントロールを得られます. あらかじめ定義された目的を持つチャンクオプションと比較すると, 出力フックはユーザー定義関数なのではるかに強力であり, 関数内ではあなたが望むことはなんでもできます.

## ソースコードを検閲する {#hook-hide}

ときにはレポートにソースコードの全文を掲載したくないこともあるでしょう. 例えばコードのある行にパスワードが書かれているかもしれません. \@ref(hide-one)節ではチャンクオプション `echo` で R コードの文ごとに表示の有無を選べることを言及しました. 例えば `echo = 2` で2つ目の文を表示します. この節では, コードのインデックスを指定する必要のない, より柔軟な方法を提供します.

基本的なアイディアはコードに特殊なコメント, 例えば `# 秘密!!` のようなものを追加するということです. このコメントがコードのある行から検出されると, 行を省略します. 以下は `source` フックを使用した完全な例です.

`r import_example('hook-secret.Rmd')`

上記の `source` フックの重要な部分はこの行です. これはソースコードの入ったベクトル `x` から `grepl()` で追跡用のコメントの `# 秘密!!` とマッチングしたものを排除しています.

```{r, eval=FALSE}
x <- x[!grepl('# SECRET!!$', x)]
```

正確に言うなら, 上記のフックは追跡用の `# 秘密!!` というコメントのある行ではなく, **評価式** (expressions) を全て排除します. `x` は実際には R 評価式のベクトルだからです. 例えば以下のコードチャンクを考えます.

```{r, source-hook-x, eval=FALSE}
1 + 1
if (TRUE) { # SECRET!!
  1:10
}
```

`source` フック内の `x` の値はこうなります.

```{r, eval=FALSE}
c("1 + 1", "if (TRUE) { # SECRET!!\n  1:10\n}")
```

R 評価式ではなく行を隠したいなら, `x` を行ごとに分割しなければなりません. `xfun::split_lines()`\index{xfun!split\_lines()} の使用を検討するとよいでしょう. フック関数の本体はこうなります.

```{r, eval=FALSE}
x <- xfun::split_lines(x)  # 個別の行に分割する
x <- x[!grepl('# SECRET!!$', x)]
x <- paste(x, collapse = '\n')  # 結合して1つの行にする
hook_source(x, options)
```

この例はソースコードの文字列を操作する方法を, そして `grepl()` は決して文字列操作の唯一の方法ではない, ということを示しています. \@ref(hook-number)節では他の例もお見せしています.

## ソースコード内に行番号を追加する {#hook-number}

この節では, ソースコードに行番号をコメントとして追加する `source` フックの定義の例を示します. 例えば, このコードチャンクに対するものを考えます.

````md
```{r}`r ''`
if (TRUE) {
  x <- 1:10
  x + 1
}
```
````

このような出力を求めているものとします.

```{r, eval=FALSE, tidy=FALSE}
if (TRUE) {    # 1
  x <- 1:10    # 2
  x + 1        # 3
}              # 4
```

完全な例は以下になります.

`r import_example('hook-number.Rmd')`

上記の例での主な小ワザは各行のコメントの前に必要なスペースの数を決めることです. これによってコメントが右揃えになっています. この数は各行のコードの文字列幅に依存しています. このフック関数の意味を咀嚼することは読者に任せます. 内部で使われている関数 `knitr:::v_spaces()`\index{knitr!v\_spaces()} は特定の長さのスペースを生成することに使われている点に注意してください. これが例です.

```{r}
knitr:::v_spaces(c(1, 3, 6, 0))
```

\@ref(number-lines)節で紹介した方法が, ソースコードに行番号を追加する方法としてあなたが本当に求めていたものかもしれません. その構文はより簡潔で, ソースコードでもテキスト出力ブロックでも動作します. 上記の `source` フックの小ワザは, カスタム関数でソースコードを操作できることの一例を示すのが主な狙いです.

## スクロール可能なテキスト出力 {#hook-scroll}

\@ref(html-scroll)節ではコードブロックとテキスト出力ブロックの高さを CSS で制御する方法を紹介しました. 実際には, もっと簡単なやり方で, チャンクオプション `attr.source` と `attr.output` を使って `style` 属性を Markdown のコードブロックに追加できます(これらのオプションの説明は\@ref(attr-output)節参照). 例えば, このようなコードに対してチャンクオプション `attr.output` を使います.

````md
```{r, attr.output='style="max-height: 100px;"'}`r ''`
1:300
```
````

Markdown 出力はこうなります.

````md
```r
1:300
```

```{style="max-height: 100px;"}
##   [1]   1   2   3   4   5   6   7   8   9  10
##  [11]  11  12  13  14  15  16  17  18  19  20
##  ... ...
```
````

そして, テキスト出力ブロックは Pandoc によって HTML へと変換されます.

```html
<pre style="max-height: 100px;">
<code>##   [1]   1   2   3   4   5   6   7   8   9  10
##  [11]  11  12  13  14  15  16  17  18  19  20
##  ... ...</code>
</pre>
```

Pandoc の fenced code blocks についてより詳しく学ぶには, https://pandoc.org/MANUAL.html#fenced-code-blocks のマニュアルを読んでください.

`attr.source` と `attr.output` オプションによって個別のコードチャンクに対して最大の高さを指定することができます. しかしこの構文は少しばかり野暮ったく, CSS と Pandoc の Markdown 構文をより理解する必要があります. 以下にカスタムチャンクオプション `max.height` と連動するカスタム `output` フックの例を示します. `attr.output = 'style="max-height: 100px;"'` の代わりに `max.height = "100px"` のようにオプションを設定するだけでよいのです. この例では `x` 引数には手を付けず, `options` 引数のみを操作しています.

`r import_example('hook-scroll.Rmd')`

図\@ref(fig:hook-scroll)がその出力です. 最後のコードチャンクにあるチャンクオプション `attr.output` に注意してください. そのオプションは `max.height` によっては上書きされないのです. なぜなら, `max.height` が生成する `style` 属性を使って既存の属性と結合することで, 既存の属性を尊重しているからです.

```{r, eval=FALSE, tidy=FALSE}
options$attr.output <- c(
  options$attr.output,
  sprintf('style="max-height: %s;"', options$max.height)
)
```

```{r, hook-scroll, echo=FALSE, fig.cap='チャンクオプション max.height を指定した, スクロール可能なテキスト出力の例'}
knitr::include_graphics(file.path(BOOKLANG, 'images/hook-scroll.png'), dpi = NA)
```

`source` フックでも同様の小ワザを使って, ソースコードブロックの高さを制限できます.

## テキスト出力を中断する {#hook-truncate}

コードチャンクから出力されたテキストが長い時, 冒頭の数行だけを表示させたくなります. 例えば数千行のデータフレームを表示する時, データ全体を表示するのは不便で, 最初の数行だけで十分でしょう. 以下では `output` フックを再定義してカスタムチャンクオプション `out.lines` によって最大行数を制御できるようにしています.

```{r}
# 組み込みの出力フックを保存
hook_output = knitr::knit_hooks$get("output")

# テキスト出力を打ち切る出力フックを新規に作成
knitr::knit_hooks$set(output = function(x, options) {
  if (!is.null(n <- options$out.lines)) {
    x = xfun::split_lines(x)
    if (length(x) > n) {
      # 出力を切断
      x = c(head(x, n), '....\n')
    }
    x = paste(x, collapse = '\n')
  }
  hook_output(x, options)
})
```

上記のフック関数の基本的なアイディアはテキスト出力の行数が, チャンクオプション `out.lines`\index{チャンクオプション!out.lines}で指定したしきい値 (関数本体では変数 `n` として保存されています) を上回ったら, 最初の `n` 行だけを残し, 省略記号 (`....`) を末尾に加え出力が打ち切られたことを表します.

以下のチャンクでチャンクオプション `out.lines = 4` を設定し, この新たな `output` フックをテストできます.

```{r, out.lines=4}
print(cars)
```

期待通りに4行の出力が現れました. 元の `output` フックを `hook_output` に保存しているので, 再度 `set()` メソッド\index{knitr!knit\_hooks}を呼び出して復元することができます.

```{r}
knitr::knit_hooks$set(output = hook_output)
```

読者への練習問題として, 異なる方法で出力を打ち切ることに挑戦してみてください. 最大行を決定するチャンクオプション `out.lines`\index{チャンクオプション!out.lines} を所与として, 末尾の行ではなく中間の行を打ち切ることができますか? 例えば `out.lines = 10` なら, このように最初と最後の5行を残し, 中間に `....` を追加します.

```text
##    speed dist
## 1      4    2
## 2      4   10
## 3      7    4
## 4      7   22
....
## 46    24   70
## 47    24   92
## 48    24   93
## 49    24  120
## 50    25   85
```

出力の最終行, つまりフック関数の引数 `x` が空白行ならば, `c(head(x, n/2), '....', tail(x, n/2 + 1))` のような処理が必要であることに注意してください. `+1` は最後の空白行を考慮するためです.

## HTML5 フォーマットで図を出力する {#hook-html5}

デフォルトでは R Markdown のグラフは HTML 上で `<p>` または `<div>` タグ内の `<img src="..." />` で読み込まれます. 以下の例は HTML5 の `<figure>` タグ\index{HTML!figure タグ}\index{図!HTML タグ}でグラフを表示する方法です.

`r import_example('hook-html5.Rmd')`

図\@ref(fig:hook-html5)がその出力です. この例では実際には `plot` フックを上書きしましたが, この章の他のほとんどの例ではデフォルトのフックの冒頭にカスタムフックを構築していることに注意してください. デフォルトのフックを完全に上書きするのは, 組み込まれている機能を無視しても構わない時に限るべきです. 例えば次の `plot` フックは `out.width ='100%'` や `fig.show = 'animate'` といったチャンクオプションがあるかもしれないことを考慮していません.

```{r hook-html5, echo=FALSE, fig.cap="HTML5 figure タグ内の図"}
knitr::include_graphics(file.path(BOOKLANG, "images/hook-html5.png"), dpi = NA)
```

この例はファイルパス `x` と `plot` フック\index{出力フック!plot}が活用できそうなことを示すものです. 図のスタイルのカスタマイズだけが必要なら, HTML5 タグを使うことはありません. 通常であれば, デフォルトの `plot` フックは以下のような HTML コードに画像を出力します.

```html
<div class="figure">
  <img src="ファイルパス" />
  <p class="caption">キャプション</p>
</div>
```

よって `div.figure` と `p.caption` に対して CSS ルールを定義するだけで可能となります.
