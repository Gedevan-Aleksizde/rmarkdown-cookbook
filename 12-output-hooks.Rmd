# 出力フック (\*) {#output-hooks}

**knitr** パッケージによって, あなたはコードチャンクから出力されるものを各パーツ, ソースコード・テキスト出力・メッセージ・グラフといったものごとに制御しています. この制御は「出力フック」\index{出力フック}\index{output hooks|see{出力フック}} (output hook(s))によって実現されています. 出力フックは出力の各パーツを入力 (典型的には文字列ベクトルとして扱います) として, 出力文書に書き出すための文字列を返す一連の関数です. 現時点ではこのしくみを理解するのは簡単ではないでしょうが, これから説明する簡単な例を見ればこのアイディアがはっきりと理解できるものと思います. この例ではコードチャンクの出力がどのようにして **knitr** の出力フックを介してレンダリングされるかを表しています.

このような1行だけのコードチャンクについて考えてみてください.

````md
```{r}`r ''`
1 + 1
```
````

**knitr** がコードチャンクを評価した後, 2つの出力要素を得て, 2つとも文字列ベクトルとして保持されます. ソースコードの `"1 + 1"` と, テキスト出力の `"[1] 2"` です. これらの文字列は求められている出力フォーマットに応じて, チャンクフックによってさらなる処理がなされます. たとえば Markdown 文書では **knitr** はソースコードを言語名を付けてコードブロックで囲みます. これは `source` フックを介して行われ, だいたいこのような関数となります.

```{r, eval=FALSE}
# 上記のケースでは, `x` は文字列 "1 + 1" に相当
function(x, options) {
  # ここの小文字 "r" は言語名を表す
  paste(c('```r', x, '```'), collapse = '\n')
}
```

同様に, テキスト出力はこのような `output` フック関数によって処理されます.

```{r, eval=FALSE}
function(x, options) {
  paste(c('```', x, '```'), collapse = '\n')
}
```

よって上記のコードチャンクの最終的な出力はこのようになります.

````md
```r
1 + 1
```

```
[1] 2
```
````

実際のフックは上記のような2つの関数よりも複雑ですが, 発想は同じです. `knit_hooks`\index{knitr!knit\_hooks} オブジェクトから `get()` メソッドで実際のフック関数を取得できます. これが例です.

```{r, eval=FALSE}
# 意味のある出力のため, 以下のコードは
# knitr 文書のコードチャンクの *内部で* 実行されるべき
knitr::knit_hooks$get('source')
knitr::knit_hooks$get('output')
# または knitr::knit_hooks$get(c('source', 'output'))
```

あなたが **knitr** パッケージの開発に貢献することに本当に関心があるのでない限り, 組み込みのフック関数のソースコードを読むことをお薦めしません. 関心があるのなら, このコードは https://github.com/yihui/knitr/tree/master/R  で `hooks-*.R` という形式で命名されたスクリプトファイルにて見ることができます. 例えば `hooks-md.R` には R Markdown 文書に対するフックが含まれています. たいていの **knitr** ユーザーにとっては, 組み込みのフックよりも便利なカスタム出力フックの作り方を知っていれば十分です. この章のこれ以降では, あなたはいくつかの例で出力フックに関するこのようなことを学びます. さらに, 我々は以下のような基本的アイディアを示します. 

カスタム出力フックは `knit_hooks()` の `set()` メソッドによって登録されます. このメソッドは既存のデフォルのトフックを上書きするので, 既存のフックのコピーを保存し, 出力要素にあなた独自の処理してから, その結果をこのデフォルトのフックに与えるようにしておくことをお薦めします. 構文はたいていこのようになります.

```{r, eval=FALSE}
# ここで local() を使うかは任意 (ここでは単に `hook_old` のような不要なグローバル変数を作ることを避ける目的)
local({
  hook_old = knitr::knit_hooks$get('NAME')  # 古いフックを保存する
  knitr::knit_hooks$set(NAME = function(x, options) {
    # ここで, x をどうしたいかにかかわらず, 新しい x を
    # さらに古いフックに与える
    hook_old(x, options)
  })
})
```

ここで, `NAME` は以下のいずれかのフックの名前を意味します.

- `source`: ソースコードを処理するフック.

- `output`: テキスト出力を処理するフック.

- `warning`: 警告 (たいていは `warning()` で発生するもの) を処理するフック.

- `message`: メッセージ (たいていは `message()` で発生するもの) を処理するフック.

- `error`: エラーメッセージ (たいていは `stop()` で発生するもの) を処理するフック.

- `plot`: グラフのファイルパスを処理するフック.

- `inline`: インライン R コードからの出力を処理するフック.

- `chunk`: チャンク全体の出力を処理するフック.

- `document`: 文書全体を処理するフック.

フック関数の引数 `x` の意味は上記のリストで説明されています. `options` 引数は現在のコードチャンクのオプションのリストを意味します. 例えば `foo = TRUE` と設定したなら, フック関数内では `options$foo` でこの値を得ることができます. `options` 引数は `inline` および `document` フックでは利用できません.

出力フックによって, チャンクと文書の出力の部品1つ1つに対して究極のコントロールを得られます. あらかじめ定義された目的を持つチャンクオプションと比較すると, 出力フックはユーザー定義関数なのではるかに強力であり, 関数内ではあなたが望むことはなんでもできます.

## ソースコードを検閲する {#hook-hide}

ときにはレポートにソースコードの全文を掲載したくないこともあるでしょう. 例えばコードのある行にパスワードが書かれているかもしれません. \@ref(hide-one)節ではチャンクオプション `echo` で R コードの文ごとに表示の有無を表せることを言及しました. 例えば `echo = 2` で2つ目の文を表示します. この節では, コードのインデックスを指定する必要のない, より柔軟な方法を提供します.

基本的なアイディアはコードに特殊なコメント, 例えば `# 秘密!!` のようなものを追加するということです. このコメントがコードのある行から検出されると, 行を省略します. 以下は `source` フックを使用した完全な例です.

`r import_example('hook-secret.Rmd')`

上記の `source` フックの重要な部分はこの行です. これはソースコードのベクトル `x` から `grepl()` で末尾の `# 秘密!!` とマッチングしたものを排除しています.

```{r, eval=FALSE}
x <- x[!grepl('# SECRET!!$', x)]
```

正確に言うなら, 上記のフックは末尾に `# 秘密!!` というコメントのある行ではなく, **評価式** (expressions) を全て排除します. `x` は実際には R 評価式のベクトルだからです. 例えば以下のコードチャンクを考えます.

```{r, source-hook-x, eval=FALSE}
1 + 1
if (TRUE) { # SECRET!!
  1:10
}
```

`source` フック内の `x` の値はこうなります.

```{r, eval=FALSE}
c("1 + 1", "if (TRUE) { # SECRET!!\n  1:10\n}")
```

R 評価式ではなく行を隠したいなら, `x` を行ごとに分割しなければなりません. `xfun::split_lines()`\index{xfun!split\_lines()} の使用を検討するとよいでしょう. フック関数の本体はこうなります.

```{r, eval=FALSE}
x <- xfun::split_lines(x)  # 個別の行に分割する
x <- x[!grepl('# SECRET!!$', x)]
x <- paste(x, collapse = '\n')  # 結合して1つの行にする
hook_source(x, options)
```

この例はソースコードの文字列を操作する方法を, そして `grepl()` はおそらく文字列操作の唯一の方法ではないだろう, ということを示しています. \@ref(hook-number)節では他の例もお見せしています.

## ソースコード内に行番号を追加する {#hook-number}

この節では, ソースコードに行番号をコメントとして追加する `source` フックの定義の例を示します. 例えば, このコードチャンクに対するものを考えます.

````md
```{r}`r ''`
if (TRUE) {
  x <- 1:10
  x + 1
}
```
````

このような出力を求めているものとします.

```{r, eval=FALSE, tidy=FALSE}
if (TRUE) {    # 1
  x <- 1:10    # 2
  x + 1        # 3
}              # 4
```

完全な例は以下になります.

`r import_example('hook-number.Rmd')`

上記の例での主要なトリックは各行のコメントの前必要なスペースの数を決めることです. これによってコメントが右揃えになっています. この数は各行のコードに依存しています. このフック関数の意味を咀嚼することは読者に任せます. 内部で使われている関数 `knitr:::v_spaces()`\index{knitr!v\_spaces()} は特定の長さのスペースを生成することに使われている点に注意してください. これが例です.

```{r}
knitr:::v_spaces(c(1, 3, 6, 0))
```

\@ref(number-lines)節で紹介した方法が, ソースコードに行番号を追加する方法としてあなたが本当に求めていたものかもしれません. そちらの構文はより簡潔で, ソースコードでもテキスト出力ブロックでも動作します. 上記の `source` フックのトリックは主に, カスタム関数でソースコードを操作する可能性の1つを示唆するのが狙いです.

## スクロール可能なテキスト出力 {#hook-scroll}

In Section \@ref(html-scroll), we showed how to restrict the heights of code blocks and text output blocks via CSS. In fact, there is a simpler method with the chunk options `attr.source` and `attr.output` to add the `style` attribute to the fenced code blocks in the Markdown output (see Section \@ref(attr-output) for more information on these options). For example, for this code chunk with the `attr.output` option:

````md
```{r, attr.output='style="max-height: 100px;"'}`r ''`
1:300
```
````

Its Markdown output will be:

````md
```r
1:300
```

```{style="max-height: 100px;"}
##   [1]   1   2   3   4   5   6   7   8   9  10
##  [11]  11  12  13  14  15  16  17  18  19  20
##  ... ...
```
````

Then the text output block will be converted to HTML by Pandoc:

```html
<pre style="max-height: 100px;">
<code>##   [1]   1   2   3   4   5   6   7   8   9  10
##  [11]  11  12  13  14  15  16  17  18  19  20
##  ... ...</code>
</pre>
```

To learn more about Pandoc's fenced code blocks, please read its manual at https://pandoc.org/MANUAL.html#fenced-code-blocks.

The `attr.source` and `attr.output` options have made it possible for us to specify maximum heights for individual code chunks. However, the syntax is a little clunky, and requires a better understanding of CSS and Pandoc's Markdown syntax. Below we show an example of a custom `output` hook that works with a custom chunk option `max.height`, so you will only need to set the chunk option like `max.height = "100px"` instead of `attr.output = 'style="max-height: 100px;"'`. In this example, we only manipulate the `options` argument, but not the `x` argument.

`r import_example('hook-scroll.Rmd')`

Figure \@ref(fig:hook-scroll) shows the output. Note that in the last code chunk with the chunk option `attr.output`, the option will not be overridden by `max.height` because we respect existing attributes by combining them with the `style` attribute generated by `max.height`:

```{r, eval=FALSE, tidy=FALSE}
options$attr.output <- c(
  options$attr.output,
  sprintf('style="max-height: %s;"', options$max.height)
)
```

```{r, hook-scroll, echo=FALSE, fig.cap='An example of scrollable text output, with its height specified in the chunk option max.height.'}
knitr::include_graphics('images/hook-scroll.png', dpi = NA)
```

You can use a similar trick in the `source` hook to limit the height of source code blocks.

## Truncate text output {#hook-truncate}

When the text output from a code chunk is lengthy, you may want to only show the first few lines. For example, when printing a data frame of a few thousand rows, it may not be helpful to show the full data, and the first few lines may be enough. Below we redefine the `output` hook so that we can control the maximum number of lines via a custom chunk option `out.lines`:

```{r}
# save the built-in output hook
hook_output = knitr::knit_hooks$get("output")

# set a new output hook to truncate text output
knitr::knit_hooks$set(output = function(x, options) {
  if (!is.null(n <- options$out.lines)) {
    x = xfun::split_lines(x)
    if (length(x) > n) {
      # truncate the output
      x = c(head(x, n), '....\n')
    }
    x = paste(x, collapse = '\n')
  }
  hook_output(x, options)
})
```

The basic idea of the above hook function is that if the number of lines of the text output is greater than the threshold set in the chunk option `out.lines`\index{chunk option!out.lines} (stored in the variable `n` in the function body), we only keep the first `n` lines and add an ellipsis (`....`) to indicate the output is truncated.

Now we can test the new `output` hook by setting the chunk option `out.lines = 4` on the chunk below:

```{r, out.lines=4}
print(cars)
```

And you see four lines of output as expected. Since we have stored the original `output` hook in `hook_output`, we can restore it by calling the `set()` method again\index{knitr!knit\_hooks}:

```{r}
knitr::knit_hooks$set(output = hook_output)
```

As an exercise for readers, you may try to truncate the output in a different way: given the chunk option `out.lines`\index{chunk option!out.lines} to determine the maximum number of lines, can you truncate the output in the middle instead of the end? For example, if `out.lines = 10`, you extract the first and last five lines, and add `....` in the middle like this:

```text
##    speed dist
## 1      4    2
## 2      4   10
## 3      7    4
## 4      7   22
....
## 46    24   70
## 47    24   92
## 48    24   93
## 49    24  120
## 50    25   85
```

Please note that the last line in the output (i.e., the argument `x` of the hook function) might be an empty line, so you may need something like `c(head(x, n/2), '....', tail(x, n/2 + 1))` (`+ 1` to take the last empty line into account).

## Output figures in the HTML5 format {#hook-html5}

By default, plots in R Markdown are included in the tag `<img src="..." />` in a `<p>` or `<div>` tag in the HTML output. This example below shows how to use the HTML5 `<figure>` tag\index{HTML!figure tag}\index{figure!HTML tag} to display plots.

`r import_example('hook-html5.Rmd')`

The figure output is shown in Figure \@ref(fig:hook-html5). Note that we actually overrode the default `plot` hook in this example, while most other examples in this chapter build custom hooks on top of the default hooks. You should completely override default hooks only when you are sure you want to ignore some built-in features of the default hooks. For example, the `plot` hook function in this case did not consider possible chunk options like `out.width = '100%'` or `fig.show = 'animate'`.

```{r hook-html5, echo=FALSE, fig.cap="A figure in the HTML5 figure tag."}
knitr::include_graphics("images/hook-html5.png", dpi = NA)
```

This example shows you what you can possibly do with the plot file path `x` in the `plot` hook\index{output hook!plot}. If all you need is to customize the style of figures, you do not have to use the HTML5 tags. Usually the default `plot` hook will output images in the HTML code like this:

```html
<div class="figure">
  <img src="PATH" />
  <p class="caption">CAPTION</p>
</div>
```

So you can just define css rules for `div.figure` and `p.caption`.
