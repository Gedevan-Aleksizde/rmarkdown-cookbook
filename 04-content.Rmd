# 文書の要素 {#document-elements}

本章では, 改ページ, YAML メタデータ, セクションヘッダ, 引用, 相互参照, 数式, アニメーション, 対話的プロット, ダイアグラム, コメントといった R Markdown 文書の要素をカスタマイズしたり生成したりするのに使える豆知識と小ワザを紹介します.

## 改ページ (改段) を挿入する {#pagebreaks}

改ページしたい場合\index{line breaks}, `\newpage` を文書に挿入できます.^[**訳注**: 正確には `\newpage` コマンドは改「段」です. 二段組の場合, 次の段に改めるため, 必ずページを改めるわけではありません.] これは LaTeX コマンドですが, **rmarkdown** パッケージは LaTeX 出力フォーマットでも, HTML, Word, ODT などのいくつかの非 LaTeX 出力フォーマットでも認識することができます.^[HTML 出力では, 改ページは HTML ページの出力時のみ意味をなし, それ以外では HTML は単一の連続したページになるため, 改ページを見ることはありません.]

例えば以下のように.

```md
---
title: Breaking pages
output:
  pdf_document: default
  word_document: default
  html_document: default
  odt_document: default
---

# 第一節

\newpage

# 第二節
```

これは Pandoc の Lua フィルタ\index{Lua filter} に基づく機能です (\@ref(lua-filters) 節参照). 技術的なことに興味のある方はこのパッケージの vignettte を見てください.

```r
vignette("lua-filters", package = "rmarkdown")
```

## 文書タイトルを動的に設定する {#dynamic-yaml}

Rmd 文書内のどこでも, YAML メタデータの部分であっても行内 R コード (\@ref(r-code)節) を使うことができます. つまり行内 R コードによって文書のタイトルなどの YAML メタデータの動的生成\index{YAML!dynamic generation}が可能ということです. 例えばこのように.

```yaml
---
title: "自動車 `r knitr::inline_expr('nrow(mtcars)')` 台の分析"
---
```

タイトルが以降の文書内で作成される R の変数に依存する場合, 以下の例のようにその後に YAML セクションを書いて `title` フィールドを加えることになるでしょう. 

````md
---
author: "利口なアナリスト"
output: pdf_document
---

我々の市場シェアを頑張って計算してみました.
I just tried really hard to calculate our market share:

```{r}`r ''`
share <- runif(1)
```

---
title: "我々の市場シェアは今や `r knitr::inline_expr('round(100 * share, 2)')`% である!"
---

これはとても `r knitr::inline_expr('if(share > 0.8) "喜ばしい" else "悲しい"')` ことです.
````

上記の例では, 変数 `share` を作成してから文書のタイトルを追加しています. Pandoc は文書内に YAML セクションをいくつ書いても読み込む (そして全てマージする) ことができるため, この例が動作します. 

タイトルだけでなくどの YAML フィールドも, パラメータ化されたレポート\index{YAML!parameters|see {parameter}}\index{parameter}から動的に生成することができます (\@ref(parameterized-reports) 節参照). 例えばこのように.

```yaml
---
title: "`r knitr::inline_expr('params$doc_title')`"
author: "利口なアナリスト"
params:
  doc_title: "デフォルトのタイトル"
---
```
タイトルが動的なパラメータなら, タイトルだけ異なるレポートのまとまりを簡単に生成できます.

この節ではタイトルを例にしましたが, このアイディアは YAML セクションのどのメタデータのフィールドにも適用可能です.

## R コード内で文書メタデータにアクセスする {#document-metadata}

Rmd 文書をコンパイルする際に, YAML セクション\index{YAML}の全てのメタデータはリストオブジェクト `rmarkdown::metadata` に保存されます. 例えば `rmarkdown::metadata$title` は文書のタイトルを与えます. YAML メタデータに与えられた情報をハードコードしなくてすむように, この `metadata` オブジェクトを R コード内で使うことができます. 例えば  **blastula** パッケージ [@R-blastula]\index{R package!blastula} で Eメールを送る時, 文書のタイトルをメールの件名に, 著者フィールドを送信者情報に使うことができます.

````md
---
title: 重要なレポート
author: John Doe
email: john@example.com
---

重要な分析ができましたので結果をメールで送りたいと思います.

```{r}`r ''`
library(rmarkdown)
library(blastula)
smtp_send(
  ...,
  from = setNames(metadata$email, metadata$author),
  subject = metadata$title
)
```
````

## 番号のない節 {#unnumbered-sections}

ほとんどの出力フォーマットは `number_sections`\index{output option!number\_sections} オプションをサポートしています. これは `true` を設定すれば節への付番を有効にできるオプションです. 例えば以下のように.

```yaml
output:
  html_document:
    number_sections: true
  pdf_document:
    number_sections: true
```

特定の節に番号を付けたくないならば, `number_sections` オプションは `true` のままにして, その節のヘッダの直後に `{-}` を加えます. 例えばこのように.

```md
# この節には番号がつきません {-}
```

全く同じことを, `{.unnumbered}` を使ってもできます. 例えば `{.unnumbered #section-id}` のように, 他の属性を追加することもできます. 詳細は https://pandoc.org/MANUAL.html#extension-header_attributes を確認してください.

付番されてない節はしばしば記述に追加の情報を与えるのに使われます. 例えば本書では, 「はじめに」と「著者について」 の章は本文では含まれないため付番されていません. 図\@ref(fig:unnumbered-sections)で見られるように, 実際の本文は付番されていない章2つの後から始まり, 本文の章は付番されています. TODO: 日本語版が出来たらスクリーンショット撮り直す.

```{r, unnumbered-sections, echo=FALSE, fig.cap='付番された章とされていない章を示すための目次のスクリーンショット'}
knitr::include_graphics('images/unnumbered-sections.png', dpi = NA)
```

節番号は漸増します. もし付番されている節の後にされていない節が挿入し, その後にさらに付番された節が開始しているなら, 節番号はそこから増加を再開します.

## 参考文献と引用 {#bibliography}

<!-- https://stackoverflow.com/questions/32946203/including-bibliography-in-rmarkdown-document-with-use-of-the-knitcitations -->

参考文献の目録\index{bibliography}を出力文書に含める方法の概観として, @bookdown2016 の [Section 2.8](https://bookdown.org/yihui/bookdown/citations.html) を見ると良いでしょう. 基本的な使用法として, YAML\index{YAML!bibliography} メタデータの `bibliography` フィールドに文献目録ファイルを指定する必要があります. 例えば BibTeX データベースが `*.bib` という拡張子の付いたプレーンテキストとして与えられているなら, このようにします.

```yaml
---
output: html_document
bibliography: references.bib  
---
```

そしてこのファイルに文献アイテムがこのようなエントリで含まれています.

```bibtex
@Manual{R-base,
  title = {R: A Language and Environment for Statistical
           Computing},
  author = {{R Core Team}},
  organization = {R Foundation for Statistical Computing},
  address = {Vienna, Austria},
  year = {2019},
  url = {https://www.R-project.org},
}
```

文書内 `@key` という構文で文献アイテムを直接引用することができます. `key` の部分エントリの最初の行にある引用キーです. 上記の例なら `@R-base` です. 括弧で囲んで引用したいなら, `[@key]` を使います. 複数のエントリを同時に引用するなら, `[@key-1; @key-2; @key-3]` のようにセミコロンでキーを区切ります. 著者名を表示しないのなら, `[-@R-base]` のように `@` の前にマイナス記号を付けます.

### 引用スタイルの変更 {#changing-citation-style}

デフォルトでは Pandoc は Chicago 式の著者名-出版年形式の引用\index{citation}スタイルと参考文献スタイルを使います. 他のスタイルを使うには, メタデータフィールド\index{YAML!csl}の `csl` で CSL (Citation Style Language) ファイルを指定します. 例えばこのように.

```yaml
---
output: html_document
bibliography: references.bib
csl: biomed-central.csl
---
```

必要としているフォーマットを見つけるには, [Zotero Style Repository,](https://www.zotero.org/styles) を使うことをおすすめします. これは必要なスタイルの検索とダウンロードが簡単にできます.

CSL ファイルはカスタマイズされたフォーマット要件に合うようにを修正できます. 例えば "et al." の前に表示する著者の人数を変更できます. これは https://editor.citationstyles.org で使用できるようなビジュアルエディタを使って簡単にできます.

### 引用していない文献を参考文献に追加する {add-an-item-to-a-bibliography-without-using-it}

デフォルトでは参考文献には文書で直接参照されたアイテムのみ表示されます. 本文中に実際に引用されていない文献を含めたい場合, `notice` というダミーのメタデータフィールド\index{YAML!nocite}を定義し, そこで引用します.

```yaml
---
nocite: |
  @item1, @item2
---
```


### 全てのアイテムを参考文献に掲載する {-add-all-items-to-the-bibliography}

文献目録のすべてのアイテムを明示的に言及したくないが, 参考文献には掲載したいというなら, 以下のような構文が使えます.

```yaml
---
nocite: '@*'
---
```

これは全てのアイテムを参考文献として強制的に掲載させます.

### 参考文献の後に補遺を掲載する (\*) {include-appendix-after-bibliography}

<!-- https://stackoverflow.com/questions/41532707/include-rmd-appendix-after-references/42258998#42258998 -->
<!-- https://stackoverflow.com/questions/16427637/pandoc-insert-appendix-after-bibliography -->

デフォルトでは参考文献は文書全体の最後に掲載されます. しかし参考文献一覧の後に追加のテキストを置きたいこともあるでしょう. 一番よくあるのは文書に補遺 (appendix) を含めたいときです. 以下に示すように, `<div id="refs"></div>` を使うことで参考文献一覧の位置を矯正できます.

```md
# References

<div id="refs"></div>

# Appendix
```

`<div>` は HTML タグですが, この方法は PDF など他の出力フォーマットでも機能します.

**bookdown** パッケージ [@R-bookdown] を使うことで, 補遺の開始前に [special header](https://bookdown.org/yihui/bookdown/markdown-extensions-by-bookdown.html#special-headers) `# (APPENDIX) Appendix {-}` の挿入が可能となり さらに改善できます. 例えば以下のように.

```md
# 参考文献

<div id="refs"></div>

# (APPENDIX) 補遺 {-} 

# 追加情報

これは「補遺 A」になる.

# さらにもう1つ

これは「補遺 B」になる.
```

LaTeX/PDF および HTML フォーマットでは補遺の付番スタイルは自動的に変更されます (たいていは A, A.1, A.2, B, B.1, ... という形式です).

## R パッケージの引用を生成する {#write-bib}

R パッケージを引用するには, base R の `citation()`\index{utils!citation()} を使うことができます. BibTeX 用の引用エントリを生成したいなら, `citation()` の返り値を `toBibtex()`\index{utils!toBibtex()} を与えることができます. 例えばこうです.

```{r, comment='', class.output='bibtex'}
toBibtex(citation('xaringan'))
```

`toBibtex()` で生成されたエントリを使うには, 出力を `.bib` ファイルにコピーし, 引用キーを追加しなければなりません (例えば `@Manual{,` の部分を `@Manual{R-xaringan,` と書き換える). これは `knitr::write_bib()`\index{knitr!write\_bib()} 関数によって自動化できます. この関数は引用エントリを生成し, 自動的にキーを加えてファイルに書き込みます. 例えばこのようにします.

```{r eval=FALSE}
knitr::write_bib(c(
  .packages(), 'bookdown'
), 'packages.bib')
```

第1引数はパッケージ名の文字列ベクトルで, 第2引数は `.bib` ファイルのパスであるべきです. 上記の例では, `.packages()` は現在の R セッションが読み込んでいる全てのパッケージ名を返します. これらのパッケージのいずれかが更新された (例えば著者, タイトル, 年, あるいはバージョンが変更された) とき, `write_bib()` は自動的に `.bib` を更新できます.

引用エントリには2つのタイプが選択肢としてあります. 1つはパッケージの `DESCRIPTION` ファイルをもとに生成したもので, もう1つは, もしパッケージに `CITATION` ファイルが存在するなら, そこから生成したものです. 前者のタイプは引用キーが `R-(パッケージ名)` という形式になり (例えば `R-knitr`), 後者のタイプはパッケージ名と公開年を結合したものがキーとなります (例: `knitr2015`). もし複数のエントリが同一年にあるなら, 接尾文字が追加されます. 例えば  `knitr2015a` と `knitr2015b` のように. 前者のタイプはしばしばパッケージ自体を引用 (つまり, ソフトウェアとして) するのに使われますが, 後者のタイプはしばしば論文や書籍のようなパッケージと関連のある出版物として扱われます.

```{r, warning=FALSE, comment='', class.output='bibtex'}
knitr::write_bib(c('knitr', 'rmarkdown'), width = 60)
```

ファイルパスの引数がないと, `knitr::write_bib()` は上記の例のように引用エントリをコンソールに出力します.

`write_bib()` は既存の文献目録ファイルを上書きするように設計されていることに注意してください. 文献目録に手動で他のエントリを追加したい場合, 2つ目の `.bib` ファイルを作成して, この例のように `bibliography`\index{YAML!bibliography} フィールドで参照してください.

````md
---
bibliography: [packages.bib, references.bib]
---

```{r, include=FALSE}`r ''`
knitr::write_bib(file = 'packages.bib')
```
````

上記の例では `packages.bib` が自動で生成されたもので, 手動で変更すべきではありません. それ以外の全ての引用エントリは `references.bib` に手動で書き込むことができます.

ここまでは R パッケージの引用を生成する方法を1つだけ紹介しています. それ以外のタイプの文献を動的に引用を生成するには,  **knitcitations** パッケージ\index{R package!knitcitations} [@R-knitcitations] を確認すると良いでしょう.

## 文書内の相互参照 {#cross-ref}

<!--https://stackoverflow.com/questions/38861041/knitr-rmarkdown-latex-how-to-cross-reference-figures-and-tables-->

Cross-referencing\index{crossreference} is a useful way of directing your readers through your document, and can be automatically done within R Markdown. While this has been explained in [Chapter 2](https://bookdown.org/yihui/bookdown/components.html) from the **bookdown** book, we want to present a brief summary below.

To use cross-references, you will need:

- **A bookdown output format**: Cross-referencing is not provided directly within the base **rmarkdown** package, but is provided as an extension in **bookdown** [@R-bookdown]. We must therefore use an output format from **bookdown** (e.g., `html_document2`, `pdf_document2`, and `word_document2`, etc.) in the YAML `output` field.

- **A caption to your figure (or table)**: Figures without a caption will be included directly as images and will therefore not be a numbered figure.

- **A labeled code chunk**:\index{code chunk!label} This provides the identifier for referencing the figure generated by the chunk.

After these conditions are met, we can make cross-references within the text using the syntax `\@ref(type:label)`, where `label` is the chunk label and `type` is the environment being referenced (e.g. `tab`, `fig`, or `eqn`). An example is provided below:

`r import_example('cross-ref.Rmd')`

The output of this document is shown in Figure \@ref(fig:bookdown-ref). 

```{r bookdown-ref, fig.cap="Example of cross-referencing within an R Markdown document.", fig.align='center', echo=FALSE}
knitr::include_graphics("images/bookdown-ref.png", dpi = NA)
```

You can also cross-reference equations, theorems, and section headers. These types of references are explained further in Section 2.2 and Section 2.6 of the **bookdown** book.

## Update the date automatically {#update-date}

<!-- https://stackoverflow.com/questions/23449319/yaml-current-date-in-rmarkdown -->

If you want the date on which the Rmd document is compiled to be reflected in the output report, you can add an inline R expression to the `date` field in YAML\index{YAML!date}, and use the `Sys.Date()` or `Sys.time()` function to obtain the current date, e.g.,

```yaml
date: "`r knitr::inline_expr('Sys.Date()')`"
```

You may want to specify the desired date or date-time format to make it more human-readable, e.g.,

```yaml
date: "`r knitr::inline_expr("format(Sys.time(), '%d %B, %Y')")`"
```

This will generate the date dynamically each time you knit your document, e.g., `r format(Sys.time(), '%d %B, %Y')`. If you wish to customize the format of the dates, you can alter the time format by providing your own format string. Here are some examples:

- `%B %Y`: `r format(Sys.time(), '%B %Y')`
- `%d/%m/%y`: `r format(Sys.time(), '%d/%m/%y')`
- `%a/%d/%b`: `r format(Sys.time(), '%a %d %b')`

A full table of POSIXct formats is shown in Table \@ref(tab:date-format).

Table: (\#tab:date-format) Date and time formats in R.

|Code |Meaning                       |Code |Meaning                                       |
|:----|:-----------------------------|:----|:---------------------------------------------|
|%a   |Abbreviated weekday           |%A   |Full weekday                                  |
|%b   |Abbreviated month             |%B   |Full month                                    |
|%c   |Locale-specific date and time |%d   |Decimal date                                  |
|%H   |Decimal hours (24 hour)       |%I   |Decimal hours (12 hour)                       |
|%j   |Decimal day of the year       |%m   |Decimal month                                 |
|%M   |Decimal minute                |%p   |Locale-specific AM/PM                         |
|%S   |Decimal second                |%U   |Decimal week of the year (starting on Sunday) |
|%w   |Decimal Weekday (0=Sunday)    |%W   |Decimal week of the year (starting on Monday) |
|%x   |Locale-specific Date          |%X   |Locale-specific Time                          |
|%y   |2-digit year                  |%Y   |4-digit year                                  |
|%z   |Offset from GMT               |%Z   |Time zone (character)                         |

As a final note, you may also want to include some explanatory text along with the date. You can add any text such as "Last compiled on" before the R code as follows:

```yaml
date: "Last compiled on `r knitr::inline_expr("format(Sys.time(), '%d %B, %Y')")`"
```

## Multiple authors in a document {#multiple-authors}

<!-- https://stackoverflow.com/questions/26043807/multiple-authors-and-subtitles-in-rmarkdown-yaml -->

We can add multiple authors to an R Markdown document within the YAML frontmatter in a number of ways\index{YAML!author}. If we simply want to list them on the same line, we can provide a single string to the document, e.g.,

```yaml
---
title: "Untitled"
author: "John Doe, Jane Doe"
---
```

Alternatively, if we wish each entry to be on its own line, we can provide a list of entries to the YAML field. This can be useful if you wish to include further information about each author such as an email address or institution, e.g.,

```yaml
---
author:
  - John Doe, Institution One
  - Jane Doe, Institution Two
---
```

We can make use of the Markdown syntax `^[]` to add additional information as a footnote to the document. This may be more useful if you have extended information that you wish to include for each author, such as providing a contact Email and address. The exact behavior will depend on the output format:

```yaml
---
author:
  - John Doe^[Institution One, john@example.org]
  - Jane Doe^[Institution Two, jane@example.org]
---
```

Certain R Markdown templates will allow you to specify additional parameters directly within the YAML. For example, the [Distill](https://rstudio.github.io/distill/) output format allows `url`, `affiliation`, and `affiliation_url` to be specified. After you install the **distill** package [@R-distill]\index{R package!distill}:

```{r, eval=FALSE}
install.packages('distill')
```

you can use the Distill format with detailed author information, e.g.,

```yaml
---
title: "Distill for R Markdown"
author:
  - name: "JJ Allaire"
    url: https://github.com/jjallaire
    affiliation: RStudio
    affiliation_url: https://www.rstudio.com
output: distill::distill_article
---
```

## Numbered figure captions {#figure-number}

<!-- https://stackoverflow.com/questions/37116632/r-markdown-html-number-figures -->

We can use **bookdown** [@R-bookdown] output formats\index{bookdown!html\_document2()} to add figure numbers to their captions. Below is an example:

```yaml
---
output: bookdown::html_document2
---
```

````md
```{r cars, fig.cap = "An amazing plot"}`r ''`
plot(cars)
```

```{r mtcars, fig.cap = "Another amazing plot"}`r ''`
plot(mpg ~ hp, mtcars)
```
````

Section \@ref(cross-ref) demonstrates how this works for other elements such as tables and equations, and how to cross-reference the numbered elements within the text. Besides `html_document2`, there are several other similar functions for other output formats, such as `pdf_document2` and `word_document2`.

You can add this feature to R Markdown output formats outside **bookdown**, too. The key is to use those formats as the "base formats" of **bookdown** output formats. For example, to number and cross-reference figures in the `rticles::jss_article` format, you can use:

```yaml
output:
  bookdown::pdf_book:
    base_format: rticles::jss_article
```

Please read the help pages of the **bookdown** output format functions to see if they have the `base_format` argument\index{output option!base\_format} (e.g., `?bookdown::html_document2`).

## Combine words into a comma-separated phrase {#combine-words}

When you want to output a character vector for humans to read (e.g., `x <- c("apple", "banana", "cherry")`), you probably do not want something like `[1] "apple" "banana" "cherry"`, which is the normal way to print a vector in R. Instead, you may want a character string "`apple, banana, and cherry`". There is a base R function, `paste()`, that you can use to concatenate a character vector into a single string, e.g., `paste(x, collapse = ', ')`, and the output will be `"apple, banana, cherry"`. The problems are (1) the conjunction "and" is missing, and (2) when the vector only contains two elements, we should not use commas (e.g., the output should be `"apple and banana"` instead of `"apple, banana"`).

The function `knitr::combine_words()`\index{knitr!combine\_words()} can be used to concatenate words into a phrase regardless of the length of the character vector. Basically, for a single word, it will just return this word; for two words A and B, it returns `"A and B"`; for three or more words, it returns `"A, B, C, ..., Y, and Z"`. The function also has a few arguments that can customize the output. For example, if you want to output the words in pairs of backticks, you may use ``knitr::combine_words(x, before = '`')``. Below are more examples with different arguments, and please see the help page `?knitr::combine_words` if the meaning of any argument is not clear from the output here:

```{r, collapse=TRUE}
v = c("apple", "banana", "cherry")
knitr::combine_words(v)
knitr::combine_words(v, before = '`', after = "'")
knitr::combine_words(v, and = "")
knitr::combine_words(v, sep = " / ", and = "")
knitr::combine_words(v[1])  # a single word
knitr::combine_words(v[1:2])  # two words
knitr::combine_words(LETTERS[1:5])
```

This function can be particularly handy when it is used in an inline R expression, e.g.,

```markdown
This morning we had `r knitr::inline_expr("knitr::combine_words(v)")` for breakfast.
```

## Preserve a large number of line breaks {#linebreaks}

Markdown users may be surprised to realize that whitespaces\index{line breaks} (including line breaks) are usually meaningless unless they are used in a verbatim environment (code blocks). Two or more spaces are the same as one space, and a line break is the same as a space. If you have used LaTeX or HTML before, you may not be surprised because the rule is the same in these languages.

In Markdown, we often use a blank line to separate elements such as paragraphs. To break a line without introducing a new paragraph, you have to use two trailing spaces. Sometimes you may want to break the lines many times, especially when you write or quote poems or lyrics. Adding two spaces after each line manually is a tedious task. The function `blogdown:::quote_poem()`\index{blogdown!quote\_poem()} can do this task automatically, e.g.,

```{r, collapse=TRUE}
blogdown:::quote_poem(c('This line', 'should be', 'broken.'))
```

If you use the RStudio IDE and have installed the package **blogdown** [@R-blogdown], you can select the text in which you want to preserve the line breaks, and click the RStudio addin "Quote Poem"\index{RStudio!Quote Poem addin} in the drop-down menu "Addins" on the toolbar. For example, the text below (in a fenced code block) does not contain trailing spaces:

```md
Like Barley Bending

Like barley bending
　In low fields by the sea,
Singing in hard wind
　Ceaselessly;

Like barley bending
　And rising again,
So would I, unbroken,
　Rise from pain;

So would I softly,
　Day long, night long,
Change my sorrow
　Into song.

--- Sara Teasdale
```

After we select the above poem and click the RStudio addin "Quote Poem," the output will be:

> Like Barley Bending  
>
> Like barley bending  
　In low fields by the sea,  
Singing in hard wind  
　Ceaselessly;
>
> Like barley bending  
　And rising again,  
So would I, unbroken,  
　Rise from pain;
>
> So would I softly,  
　Day long, night long,  
Change my sorrow  
　Into song.
>
> ::: {.flushright data-latex=""}
> --- Sara Teasdale
> :::

Some users may ask, "Since the fenced code block preserves whitespaces, why not put poems in code blocks?" Code could be poetic, but poems are not code. Please do not be too addicted to coding...

## Convert models to equations {#equatiomatic}

The **equatiomatic** package\index{R package!equatiomatic} (https://github.com/datalorax/equatiomatic) developed by Daniel Anderson et al. provides a convenient and automatic way to show the equations corresponding to models fitted in R. We show a few brief examples below:

```{r, results='asis'}
fit <- lm(mpg ~ cyl + disp, mtcars)
# show the theoretical model
equatiomatic::extract_eq(fit)
# display the actual coefficients
equatiomatic::extract_eq(fit, use_coefs = TRUE)
```

To display the actual math equations, you need the chunk option `results = "asis"`\index{chunk option!results} (see Section \@ref(results-asis) for the meaning of this option), otherwise the equations will be displayed as normal text output.

Please read the documentation and follow the development of this package on GitHub if you are interested in knowing more about it.

## Create an animation from multiple R plots {#animation}

When you generate a series of plots in a code chunk, you can combine them into an animation\index{animation}. It is easy to do so if the output format is HTML---you only need to install the **gifski** package\index{R package!gifski} [@R-gifski] and set the chunk option `animation.hook = "gifski"`\index{chunk option!animation.hook}. Figure \@ref(fig:pacman) shows a simple "Pac-man" animation created from the code chunk below:

````md
```{r, animation.hook="gifski"}`r ''`
for (i in 1:2) {
  pie(c(i %% 2, 6), col = c('red', 'yellow'), labels = NA)
}
```
````

```{r pacman, animation.hook=if (knitr::is_html_output()) 'gifski', echo=FALSE, fig.cap='A Pac-man animation.', fig.show='hold', out.width=if (knitr::is_latex_output()) '50%'}
par(mar = rep(0, 4))
for (i in 1:2) {
  pie(c(i %% 2, 6), col = c('red', 'yellow'), labels = NA)
}
```

The image format of the animation is GIF, which works well for HTML output, but it is not straightforward to support GIF in LaTeX. That is why you only see two static image frames in Figure \@ref(fig:pacman) if you are reading the PDF or printed version of this book. If you read the online version of this book, you will see the actual animation.

Animations can work in PDF, but there are two prerequisites. First, you have to load the LaTeX package [**animate**](https://ctan.org/pkg/animate) (see Section \@ref(latex-extra) for how). Second, you can only use Acrobat Reader to view the animation. Then the chunk option `fig.show = "animate"`\index{chunk option!fig.show} will use the **animate** package\index{R package!animate} to create the animation. Below is an example:

`r import_example('latex-animation.Rmd')`

The time interval between image frames in the animation can be set by the chunk option `interval`\index{chunk option!interval}. By default, `interval = 1` (i.e., one second).

The R package **animation**\index{R package!animation} [@R-animation] contains several animation examples to illustrate methods and ideas in statistical computing. The **gganimate** package\index{R package!gganimate} [@R-gganimate] allows us to create smooth animations based on **ggplot2**\index{R package!gglot2} [@R-ggplot2]. Both packages work with R Markdown.

## Create diagrams {#diagrams}

There are many separate programs (e.g., Graphviz) that can be used to produce diagrams\index{figure!creating diagrams} and flowcharts, but it can be easier to manage them directly inside R code chunks in Rmd documents. 

While there are several different packages available for R, we will only briefly introduce the package **DiagrammeR**\index{R package!DiagrammeR} [@R-DiagrammeR], and mention other packages at the end. You can find the full documentation of **DiagrammeR** at https://rich-iannone.github.io/DiagrammeR/. In this section, we will introduce the basic usages and also how to use R code in diagrams.

### Basic diagrams

**DiagrammeR** provides methods to build graphs for a number of different graphing languages. We will present a Graphviz example in this section,^[Depending on your background, this section may be a biased introduction to **DiagrammeR**. Please see its official documentation if you are interested in this package.] but you can also use pure R code to create graphs and diagrams with **DiagrammeR**.

The RStudio IDE provides native support for Graphviz (`.gv`) and mermaid (`.mmd`) files. Editing these types of files in RStudio has the advantage of syntax highlighting. RStudio also allows you to preview the diagrams by clicking the "Preview" button on the toolbar. Figure \@ref(fig:diagram-profit) is a simple flowchart example that has four rectangles representing four steps, generated by the code below:

```{r diagram-profit, fig.align='center', fig.cap="A diagram showing a programmer's daydream.", fig.dim=c(3, 6), out.width="100%"}
DiagrammeR::grViz("digraph {
  graph [layout = dot, rankdir = TB]
  
  node [shape = rectangle]        
  rec1 [label = 'Step 1. Wake up']
  rec2 [label = 'Step 2. Write code']
  rec3 [label =  'Step 3. ???']
  rec4 [label = 'Step 4. PROFIT']
  
  # edge definitions with the node IDs
  rec1 -> rec2 -> rec3 -> rec4
  }",
  height = 500)
```

There are extensive controls that can be used to define the shape of nodes, colors, line types, and add additional parameters.

### Adding parameters to plots

Graphviz substitution allows for mixing R expressions into a Graphviz graph specification, without sacrificing readability. If you specify a substitution with `@@`, you must ensure there is a valid R expression for that substitution. The expressions are placed as footnotes and their evaluations must result in an R vector object. The `@@` notation is immediately followed by a number, and that number should correspond to the number of the R expression footnote. Figure \@ref(fig:diagram-params) shows an example of embedding and evaluating R code in the diagram.

```{r diagram-params, fig.cap="A diagram using parameters input from R.", fig.dim=c(6, 1), out.width="100%", crop=TRUE}
DiagrammeR::grViz("
  digraph graph2 {
  
  graph [layout = dot, rankdir = LR]
  
  # node definitions with substituted label text
  node [shape = oval]
  a [label = '@@1']
  b [label = '@@2']
  c [label = '@@3']
  d [label = '@@4']
  
  a -> b -> c -> d
  }
  
  [1]: names(iris)[1]
  [2]: names(iris)[2]
  [3]: names(iris)[3]
  [4]: names(iris)[4]
  ",
  height = 100)
```

### Other packages for making diagrams

You may also check out these packages for creating diagrams: **nomnoml** [@R-nomnoml], **diagram** [@R-diagram], **dagitty** [@R-dagitty], **ggdag** [@R-ggdag], and **plantuml** (https://github.com/rkrug/plantuml).

## Escape special characters {#special-chars}

Some characters have special meanings in the Markdown syntax. If you want these characters verbatim, you have to escape them. For example, a pair of underscores surrounding text usually makes the text italic. You need to escape the underscores if you want verbatim underscores instead of italic text. The way to escape a special character is to add a backslash before it, e.g., `I do not want \_italic text\_ here`. Similarly, if `#` does not indicate a section heading, you may write `\# This is not a heading`.

As mentioned in Section \@ref(linebreaks), a sequence of whitespaces will be rendered as a single regular space. If you want to render the sequence of spaces literally, you need to escape each of them, e.g., `keep the social \ \ \ distance`. When a space is escaped, it is converted to a "non-breaking space," which means the line will not be wrapped at this space, e.g., `Mr.\ Dervieux`.

## Comment out text {#comments}

<!-- https://stackoverflow.com/questions/17046518/comment-out-text-in-r-markdown -->

It is useful to comment out text\index{comment} in the source document, which will not be displayed in the final output document. For this purpose, we can use the HTML syntax `<!-- your comment -->`. The comments will not be displayed in any output format.

Comments can span either a single line or multiple lines. This may be useful for you to write draft content.
<!-- TODO: it also allows us to comment out code chunks and prevent them from being run in knitr (not possible at the moment). -->

If you use RStudio, you can use the keyboard shortcut\index{RStudio!comment shortcut} `Ctrl + Shift + C` (`Command + Shift + C` on macOS) to comment out a line of text.

## Omit a heading in the table of contents {#toc-unlisted}

If you do not want certain section headings to be included in the table of contents, you can add two classes to the heading: `unlisted`\index{class!unlisted} and `unnumbered`\index{class!unnumbered}. For example:

```md
# Section heading {.unlisted .unnumbered}
```

Note that this feature requires at least Pandoc 2.10. You may check your Pandoc version via `rmarkdown::pandoc_version()`. If the version is lower than 2.10, you may install a newer version (see Section \@ref(install-pandoc)).

## Put together all code in the appendix (\*) {#code-appendix}

Unless the target readers are highly interested in the computational details while they read a report, you may not want to show the source code blocks in the report. For this purpose, you can set the chunk option `echo = FALSE`\index{chunk option!echo} to hide the source code instead, so readers will not be distracted by the program code for computing. However, the source code is still important for the sake of reproducible research. Sometimes readers may want to verify the computational correctness after they have finished reading the report. In this case, it can be a good idea to hold all code blocks in the body of the report, and display them at the end of a document (e.g., in an appendix).

There is a simple method of extracting all code chunks in a document and putting them together in a single code chunk using the chunk option `ref.label`\index{chunk option!ref.label} and the function `knitr::all_labels()`\index{knitr!all\_labels()}, e.g.,

````md
# Appendix: All code for this report

```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}`r ''`
```
````

Please read Section \@ref(ref-label) if you are not familiar with the chunk option `ref.label`.

The function `knitr::all_labels()` returns a vector of all chunk labels in the document, so `ref.label = knitr::all_labels()` means retrieving all source code chunks to this code chunk. With the chunk options `echo = TRUE` (display the code) and `eval = FALSE`\index{chunk option!eval} (do not evaluate this particular code chunk because all code has been executed before), you can show a copy of all your source code in one code chunk.

Since `ref.label` can be a character vector of arbitrary chunk labels, you can certainly filter the labels to decide a subset of code chunks to display in the code appendix. Below is an example (credits to [Ariel Muldoon](https://yihui.org/en/2018/09/code-appendix/)) of excluding the labels `setup` and `get-labels`:

````md
```{r get-labels, echo = FALSE}`r ''`
labs = knitr::all_labels()
labs = setdiff(labs, c("setup", "get-labels"))
```

```{r all-code, ref.label=labs, eval=FALSE}`r ''`
```
````

You can also filter code chunks using the arguments of `knitr::all_labels()`. For example, you may use `knitr::all_labels(engine == "Rcpp", echo == FALSE)` to obtain all your code chunks that use the `Rcpp` engine (`engine == "Rcpp"`) and are not displayed in the document (`echo = FALSE`). If you want precise control over which code chunks to display in the appendix, you may use a special chunk option `appendix = TRUE` on certain code chunks, and `ref.label = knitr::all_labels(appendix == TRUE)` to obtain the labels of these code chunks.

## Manipulate Markdown via Pandoc Lua filters (\*) {#lua-filters}

\index{Pandoc!Lua filter|see  {Lua filter}}

Technically, this section may be a little advanced, but once you learn how your Markdown content is translated into the Pandoc abstract syntax tree (AST), you will have the power of manipulating any Markdown elements with the programming language called Lua.

Basically, when Pandoc reads a Markdown file, the content will be parsed into an AST. Pandoc allows you to modify this AST with Lua scripts\index{Lua filter}. We use the following simple Markdown file (named `ast.md`) to show what the AST means:

```{cat, engine.opts=list(file='ast.md', lang='md')}
## Section One

Hello world!
```

This file contains a header and a paragraph. After Pandoc parses this content, it may be easier for R users to understand the resulting AST if we convert the file to the JSON format:

```{sh}
pandoc -f markdown -t json -o ast.json ast.md
```

Then read the JSON file into R, and print out the data structure. 

When you do this, you will see that the Markdown content is represented in a recursive list. Its structure is printed below. The label `t` stands for "type," and `c` stands for "content." Take the header for example. Its type is "Header", and its content has three sub-elements: the header level (`2`), the attributes (e.g., the ID is `section-one`), and the text content.

```{r, comment='', tidy=FALSE}
xfun:::tree(
  jsonlite::fromJSON('ast.json', simplifyVector = FALSE)
)
```

After you are aware of the AST, you can modify it with the Lua programming language. Pandoc has a built-in Lua interpreter, so you do not need to install additional tools. The Lua scripts are called "Lua filters" for Pandoc. Next we give a quick example of raising the levels of headers by one, e.g., convert level 3 headers to level 2 headers. This may be useful when the top-level headers of your document are level 2 headers, but you want to start with level 1 headers instead.

First, we create a Lua script file named `raise-header.lua`, which contains a function named `Header`, indicating that we want to modify elements of the type "Header" (in general, you can use the type name as the function name to process elements of a certain type):

```{cat, engine.opts=list(file='raise-header.lua', lang='lua')}
function Header(el)
  -- The header level can be accessed via the attribute 'level'
  -- of the element. See the Pandoc documentation later.
  if (el.level <= 1) then
    error("I don't know how to raise the level of h1")
  end
  el.level = el.level - 1
  return el
end
```

Then we can pass this script to Pandoc via the argument `--lua-filter`, e.g.,

```{sh, comment=''}
pandoc -t markdown --atx-headers \
  --lua-filter=raise-header.lua ast.md
```

You can see that we have successfully converted `## Section One` to `# Section One`. You may feel this example is trivial, and wonder why not simply replace `##` with `#` with a regular expression like:

```{r, eval=FALSE}
gsub('^##', '#', readLines('ast.md'))
```

Usually it is not robust to manipulate a structured document with regular expressions, because there are almost always exceptions, e.g., what if `##` means a comment in R code? The AST gives you the structured data, so you know for sure that you are modifying the expected elements.

Pandoc has extensive documentation on Lua filters at https://pandoc.org/lua-filters.html, where you can find a large number of examples. You can also find some filters written by the community in the GitHub repository at https://github.com/pandoc/lua-filters.

In the R Markdown world, below is an incomplete list of packages that have made use of Lua filters (usually they are in the `inst/` directory):

- The **rmarkdown** package (https://github.com/rstudio/rmarkdown) contains filters that insert page breaks (see Section \@ref(pagebreaks)) and generate custom blocks (see Section \@ref(custom-blocks)).

- The **pagedown** package [@R-pagedown] contains filters that help implement footnotes and the list of figures on HTML pages.

- The **govdown** package [@R-govdown] contains filters to convert Pandoc's fenced `Div`s to appropriate HTML tags.

You can also find an example in Section \@ref(lua-color) in this book, which shows you how to change the text color with a Lua filter.

For R Markdown users who do not want to create R packages to ship the Lua filters (like the above packages), you may store these Lua scripts anywhere on your computer, and apply them through the `pandoc_args`\index{output option!pandoc\_args} option of an R Markdown output format, e.g.,

```yaml
---
output:
  html_document:
    pandoc_args:
      - --lua-filter=raise-header.lua
---
```

```{r, include=FALSE}
unlink(c('ast.md', 'ast.json', 'raise-header.lua'))
```
