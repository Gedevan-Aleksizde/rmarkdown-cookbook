# 概念に関する概観 {#conceptual-overview}

このテキストの目標は R Markdown を最大限活用するために多くの豆知識と小技を見せることです. 以降の各章ではより効率的で簡潔なコードを書き, 出力をカスタマイズする技術を実演します. これを始める前に, これらを理解し, 覚え, 応用し, 「リミックス」できる助けになるよう, R Markdown の動作がどうなっているかを少しだけ学んでおくと役に立つでしょう. この節では文書を knit する処理と出力を変更する「重要な切り替えレバー」について簡潔に概観します. この資料は後の章の内容理解に必要ではありません (読み飛ばすのは自由です!) が, 全てのピースをどう当てはめるかについて, より豊かなメンタルモデルを構築する助けになるかもしれません.

## レンダリング時に何が起こっているのか {#rmarkdown-process}

R Markdown はいくつかの異なるプロセスを合わせて文書を作成し, これが R Markdown の全ての部品がどう連動してるかに関する混乱の主な理由です.^[Allison Horst が R Markdown の処理を魔法になぞらえたすばらしいイラストに描き出してくれました (https://github.com/allisonhorst/stats-illustrations/raw/master/rstats-artwork/rmarkdown_wizards.png). そして実際のところ, この絵は本書の扉絵に使われました.] 幸運にも, ユーザーが文書を作成できるようになるためにはこれらの処理の内部の挙動を全て理解することは必須ではありません. しかし, 文書の挙動の変えようとするだろうユーザーにとっては, どの部品がどの挙動を担当しているかを理解することは重要です. あなたが検索する適切な範囲を絞れるようになれば, ヘルプを探すのがより簡単になります.

R Markdown 文書に対する基本的なワークフローの構造を図\@ref(fig:rmdworkflow)に示します. ステップ (矢印) と, 出力ファイルが生成される前に作成される中間ファイルを強調しています. 全ての処理は `rmarkdown::render()` 関数内で実装されています. 以降は各段階を詳細に説明します.

```{r rmdworkflow, echo = FALSE, fig.cap = "R Markdown 文書がどのように最終的な出力文書に変換されるかを表すダイアグラム", out.width='100%'}
knitr::include_graphics("images/workflow.png", dpi = NA)
```

`.Rmd` 文書は, 文書の本来の形式です. YAML (メタデータ)\index{YAML}, テキスト (ナラティブ), コードチャンク\index{コードチャンク} を含んでいます.

最初に **knitr**\index{knitr} [@R-knitr] の `knit()` 関数が `.Rmd` ファイルに埋め込まれた全てのコードを実行することになり, そして出力文書にコードの出力を表示します. 全ての結果は, 一時的に作られた `.md` ファイルに含まれるよう, 適正なマークアップ言語へと変換されます.

その後 `.md` ファイルは, あるマークアップ言語のファイルから別のものへと変換するための多用途なツールである Pandoc\index{Pandoc} によって処理されます. 文書を `output` パラメータで指定された (HTML へ出力する `html_document` のような) 出力形式へ変換するため, 文書の YAML フロントマターで指定されたパラメータを取ります (例: `title`, `author`, `date`).

出力形式が PDF ならば, Pandoc が中間ファイルの `.md` を `.tex` ファイルに変換する時にさらに処理が1層, 追加されます. このファイルはその後, 最終的な PDF 文書を形成するため LaTeX によって処理されます. \@ref(install-latex) 節で話したように, **rmarkdown** パッケージは **tinytex** パッケージ @R-tinytex] の `latexmk()` 関数を呼び出し, これが次々に LaTeX を呼び出して `.tex` をコンパイルし `.pdf` にします.

簡潔にまとめると, `rmarkdown::render()` = `knitr::knit()` + Pandoc (PDF の場合のみ + LaTeX) ということです.

Robin Linacre が https://stackoverflow.com/q/40563479/559676 で R Markdown と **knitr** と Pandoc の関係について良い要約を書いてくれました. この投稿には上記の概観よりも技術的に細かい話も含まれています.

全ての R Markdown 文書が常に Pandoc を通してコンパイルされるわけではないことに注意してください. 中間ファイル `.md` は他の Markdown レンダラによってもコンパイルできます. 例えば2つ例を挙げます. 

- **xaringan**\index{xaringan} パッケージ [@R-xaringan] は出力された `.md` をウェブブラウザ上で Markdown コンテンツを表示するための JavaScript ライブラリに渡します.^[**訳注**: **xaringan** について日本語で言及している例は少ないですが, 次のページが用法・技術的な説明の両面で優れています. https://qiita.com/nozma/items/21c56c7319e4fefceb79]

- **blogdown**\index{blogdown} パッケージは [@R-blogdown] `.Rmarkdown` 文書形式をサポートしています. これは `.Rmarkdown` を knit して `.markdown` にし, Markdown 文書は大抵の場合外部のサイトジェネレータによって HTML にレンダリングされます.

## R Markdown の解剖学 {#rmarkdown-anatomy}

R Markdown にいくつかの部品があることを考えながら, 我々は1レベル深く掘り下げることができます. では, レンダリング作業中にいつどのように処理を変化させるかに注目してみましょう.

### YAML メタデータ {#yaml-metadata}

YAML metadata\index{YAML} (YAML ヘッダとも呼びます) はレンダリング処理の中の多くのステージで処理され, 様々な形で最終的な文書に作用することことができます. YAML メタデータは Pandoc, **rmarkdown**, そして **knitr** のそれぞれに読み込まれます. その過程で, メタデータに含まれる情報はコード, コンテンツ, そしてレンダリング処理に影響しうるものです.

典型的な YAML ヘッダはこのように, 文書と基本的なレンダリング操作指示に関する基本的なメタデータを含んでいます.

```yaml
---
title: My R Markdown Report
author: Yihui Xie
output: html_document
---
```

この場合,  `title`, `author` フィールドは Pandoc によって処理され, テンプレート変数の値に設定されます. デフォルトのテンプレートでは, `title` と `author` の情報は得られた文書の冒頭に現れます. Pandoc が YAML ヘッダの情報をどう扱うかのより詳細な話は, Pandoc マニュアルの [YAML metadata block.](https://pandoc.org/MANUAL.html#extension-yaml_metadata_block) に関するセクションで見られます.^[**訳注**: 日本語訳での対応箇所はこちら: https://pandoc-doc-ja.readthedocs.io/ja/latest/users-guide.html#metadata-blocks]

対照的に `output` フィールドはレンダリング処理の中で **rmarkdown** が出力フォーマット関数 `rmarkdown::html_document()` に適用するのに使われます `output` に指定した出力フォーマットに引数をあたえることで, レンダリング処理に影響させることができます. 例えばこのように書きます.

```yaml
output:
  html_document:
    toc: true
    toc_float: true
```

これは `rmarkdown::render()` に, `rmarkdown::html_document(toc = TRUE, toc_float = TRUE)` と指示することと同じです. これらのオプションが何をするのか知るために, あるいは使える他のオプションを知るために, R コンソールで `?rmarkdown::html_document` を実行してヘルプページを読むことになるでしょう. `output: html_document` は `output: rmarkdown::html_document` と等価であることに注意してください. 出力フォーマットが `rmarkdown::` のような修飾子を持たない場合, **rmarkdown** パッケージのものと想定されます. そうでないなら, R パッケージ名のプレフィックスが必要です. 例えば `bookdown::html_document2` のような.

\@ref(parameterized-reports) 節に書いたように, YAML ヘッダ内でパラメータを選択したのなら, コンテンツとコードにも影響することができます. 簡潔に言うと, R Markdown ドキュメント全体で参照可能な変数や R 評価式をヘッダに含めることができるということです. 例えば以下のヘッダでは `start_date` と `end_date` パラメータを定義し, これらは以降の R Markdown 文書内で `params` というリスト内に反映されます. つまり, R コード内でこれらを使うことができ, `params$start_date` と `params$end_date` でアクセスできるということです.

```yaml
---
title: My RMarkdown
author: Yihui Xie
output: html_document
params:
  start_date: '2020-01-01'
  end_date: '2020-06-01'
---
```

### ナラティブ {#narrative}

TODO: ナラティブ, 訳し方
R Markdown のナラティブテキスト要素は YAML メタデータやコードチャンクよりは理解が簡単でしょう. 典型的には, これはテキストエディタで書いているようなものだと感じられるでしょう. しかし Markdown コンテンツは, どのようにコンテンツが作られるか, どうやって文書の構造がそこから作られるか, の両方に関して, 単純なテキストよりも強力で面白いものに違いありません.

我々のナラティブの多くは人の手で書かれていますが, 多くの R Markdown 文書ではコードと使用される分析を参照することが求められているようです. この理由として, \@ref(document-elements) 章において, コードがテキストの一部を生成するのを助ける様々な方法が実演されています. 単語を結合してリストにしたり (\@ref(combine-words)節), 参考文献リストを書いたり (\@ref(bibliography)節)といったやり方です. この変換は `.Rmd` から `.md` への変換と同様に **knitr**\index{knitr} で制御されます.

Markdown のテキストは文書の構造も与えることができます. Markdown の構文をこの場で復習するには紙面が足りませんが,^[Markdown の復習には, 代わりに, https://bookdown.org/yihui/bookdown/markdown-syntax.html をご覧になってください.] 特に関連深い概念の1つとしてセクション (節) ヘッダがあります. これは 1つ以上の, 対応したレベルの数のハッシュ (`#`) で表現されます. 例えば, 以下のように.

```md
# First-level header

## Second-level header

### Third-level header
```

TODO: section はセクションで統一するか節で統一するか. chapter との兼ね合い

これらのヘッダは **rmarkdown** が `.md` を最終的な出力フォーマットに変換する際に文書全体に構造を与えます. この構造は, いくつかの属性を付与することで節を参照し形成するのに役立ちます. Pandoc 構文は, ヘッダの記述に `{#id}` と続けることで参照を作成することが可能になり, あるいは `{.クラス名}` のように書くこと節に複数のクラスを付与できます. 例えば以下のように.

```md
## Second-level header {#introduction .important .large}
```

例えば ID やクラスで参照するといった, これから学ぶいくつもの方法で, この節にアクセスすることが出来ます. 具体例として, \@ref(cross-ref)節では節IDを使って文書内のどこでも相互参照する方法を実演していますし, \@ref(html-tabs)節では小節を認識させる `.tabset` クラスを紹介しています.

R Markdown のテキスト部分で見られる最後の興味深いコンテンツのタイプとして, 特定の出力したいフォーマットに対して「生のコンテンツ」をそのまま書き出す方法, 例えば LaTeX 出力に対して LaTeX コードを直接書く (\@ref(raw-latex) 節), HTML 出力に対して HTML コードを直接書く, 等 (\@ref(raw-content) 節), を挙げます. 生のコンテンツは基本的な Markdown ではできないことが達成できますが, 出力フォーマットが異なるとたいていは無視されることに留意してください. 例えば生の LaTeX コマンドは出力が HTML の場合, 無視されます.

### コードチャンク {#code-chunks}

コードチャンク\index{code chunk}は R Markdown にとっての心臓の鼓動です. チャンク内のコードは **knitr** によって実行され, 出力は Markdown に翻訳され, レポートは現在のスクリプトとデータに動的に同期します. 各コードチャンクは言語エンジン (\@ref(other-languages)章), ラベル, チャンクオプション (\@ref(chunk-options)章), そしてコードで構成されます.

コードチャンクを作ることができるいくつかの mod について理解するためには, **knitr** の処理をあとほんの少しだけ詳しく知ることが有意義です. 各チャンクでは, **knitr** 言語エンジンは3つの入力の部品を得ます. knit 環境 (`knitr::knit_global()`), コードの入力, 任意に指定できるラベル, そしてチャンクオプションのリストです. コードチャンクはコードもその出力も整形された表現として返します. 副作用として, knit 環境も修正されます. 例えばコードチャンク内のソースコードを介してこの環境内で新しい変数がつくられます. この処理は図\@ref(fig:knitr-workflow)のように表せます.

```{r knitr-workflow, echo = FALSE, fig.cap = '言語エンジンへの入出力フローチャート', out.width = '100%', fig.dim=c(7, 3.5), fig.align='center', cache=TRUE}
nomnoml::nomnoml(
  "
  [<frame>コードチャンク|
  [コード]->[言語エンジン]
  [チャンクオプション]->[言語エンジン]
  [環境]->[言語エンジン]
  [言語エンジン]->[整形されたコード]
  [言語エンジン]->[整形された出力]
  [言語エンジン]->[(変更された) 環境]
  ]")
```

この処理は以下の方法で修正できます.

- 言語エンジンを変更する

- チャンクオプションを, グローバルあるいはローカル, あるいは特定の言語に対してのみ修正する

- 入出力にさらなる処理を追加するためのフックを使用する

例えば\@ref(hook-hide)節で, ソースコードの特定行を改ざんする後処理をするフックを加える方法を学ぶことになるでしょう.

コードチャンクは\@ref(narrative)節でつぶさに見てきたナラティブのようなクラスと識別子を持ちます. コードチャンクは識別子 (よく「チャンクラベル」と呼ばれます) を言語エンジンの直後に任意で指定することができます. チャンクオプション `class.source` と `class.output` でそれぞれコードブロックとテキスト出力ブロックに対するクラスを設定することもできます (\@ref(chunk-styling)節参照). 例えばチャンクヘッダ ```` ```{r summary-stats, class.output = 'large-text'}```` はチャンクラベルに `summary-stats` を与え, テキスト出力ブロックに `large-text` というクラスを与えています. チャンクのラベルは1つだけですが, クラスは複数持つことができます.

### 文書の本文 {#document-body}
 
文書を執筆し編集するに際して理解すべき重要なことは, どのようにしてコードとナラティブの小片が文書内のいくつもの節やコンテナを作るのかです. 例えばこのような文書があったとします.

````md
# タイトル

## X 節

ここから導入文

```{r chunk-x}`r ''`
x <- 1
print(x)
```

### 第1小節

ここに詳細な話

### 第2小節

ここにさらに詳しい話

## Y 節

ここから新しい節

```{r chunk-y}`r ''`
y <- 2
print(y)
```
````

この文書を書いていると, それぞれの小片は, テキストとコードを含んだ, 独立した節とともに直線上に並んでいるものとみなすかもしれません. しかし実際にしているのは, 概念としては図\@ref(fig:rmd-containers)でより細かく描いているように, 入れ子 (ネスト) になったコンテナの作成です^[現実に, ここで見えているよりも多くのコンテナがあります. 例えば knit されたコードチャンクや, コードと出力がそれぞれ別のコンテナとして存在し, そしてこれらは親要素を共有しています.]

```{r rmd-containers, echo = FALSE, fig.cap = '入れ子状のコンテナとして表現された単純な R Markdown 文書の例', out.width = '50%', fig.align='center', cache=TRUE}
nomnoml::nomnoml(
  "
  [タイトル (レベル 1)|
  
    [節 X (レベル 2)| - テキスト | - コード (チャンク-x) | - 第1小節 | - 第2小節]
    [節 Y (レベル 2)| - テキスト | - コード (チャンク-y) ]

  ]")
```

この図に関する2つの重要な特徴は (1) テキストやコードのどのセクションも個別のコンテナであり, (2) コンテナは他の別のコンテナを入れ子にできる, ということです. この入れ子は R Markdown 文書を RStudio IDE で執筆し, 文書のアウトラインを展開しているとはっきりと分かります.

図\@ref(fig:rmd-containers)では同じレベルのヘッダは同じレベルの入れ子を表していることに注意してください. 低レベルのヘッダはより高レベルなヘッダのコンテナ内部にあります. この場合, 通常は高レベルの節を「親」といい, 低レベルの節を「子」といいます. 例えば「小節」は「節」の子です. \@ref(multi-column)節で実演するように, ヘッダだけでなく `:::` を使ってまとまりの単位を作ることができます

このテキストで説明されているフォーマットやスタイルのオプションを適用するとき, この構造は重要な意味を持ちます. 例えば, Pandoc が抽象構文木 (AST) でどのように文書を表現するかを学ぶ時 (\@ref(lua-filters)節) や, HTML出力のスタイルを決めるために CSS セレクタを使用する時 (\@ref(html-css)節ほか), 入れ子構造の概念が現れます.

フォーマットとスタイルは似たようなタイプのコンテナ (例えばコードブロック) や, あるコンテナ内に全てあるコンテナ (例: 「Y 節」以下にある全てのコンテナ) に対して適用できます. 加えて\@ref(narrative)節で説明したように, 同一のクラスをある節に対して同様のものとして扱うために適用することができますし, この場合は共通のクラス名は共通のプロパティ, あるいはこの節に共通の意図を示すようになります.

本書を読みながら, 特定の「レシピ」がどんな種類のコンテナに対して作用しているのかを自問し, 考えることはあなたにとって有益になるでしょう.

## 結果を変更するために, なにを変更できるか? {#what-to-change}

では, ここまでで概観してきたものを要約し, これから何をすべきかを下見していきましょう.

**rmarkdown** で R Markdown 文書をレンダリングする処理は **knitr** で `.Rmd` を `.md` で変換する処理, それから (典型的には) Pandoc で `.md` を望む出力に変換する処理で構成されます.

`.Rmd` から `.md` 変換のステップではレポート内の全てのコードの実行と「翻訳」を制御するため, 「コンテンツ」への変更のほとんどは, **knitr** の翻訳するためのコードを伴う `.Rmd` を編集する作業が絡んできます. これらのステップ全体を操作するツールには **knitr** チャンクオプションおよびフックがあります.

`.md` はフォーマットされていないプレーンテキストです. ここで Pandoc の出番です. HTML や PDF, Word といった最終的な出力フォーマットへ変換されます. この途上で構造とスタイルを付与します. この処理では スタイルシート (CSS), 生 LaTeX または HTML コード, Pandoc テンプレート, Lua フィルタといった様々なツールが助けになります. R Markdown 文書の入れ子構造を理解し, よく考えて識別子とクラスを使うことで, これらのツールを取捨選択して出力の目標となる箇所に応用することができます.

最後に, YAML メタデータはこれらのステップの切り替えに役に立つかも知れません. パラメータの変更はコードがどう動作するかを変更することができ, メタデータの変更はテキストの内容を変化させ, 出力オプションの変更は, 異なる命令のセットをもつ `render()` 関数を与えます.

もちろんこれらは全て大まかな経験則であり, 絶対的な事実として扱うべきでありません. 究極的には, 機能を完璧にきれいに分類することはできません. 本書全体を通じて, 説明されている結果の多くは, しばしば実現のための道筋が複数あり, さらにそのパイプラインの様々なステージの説明に立ち入ることになることが分かるでしょう. 例えば文書内に画像を挿入する作業では, `.Rmd` から `.md` への変換の段階で R コード `knitr::include_graphics()` を使うこともあれば, Markdown 構文 (`![]()`) を直接使うこともあるでしょう. ややこしく思えるかもしれませんし, アプローチごとに異なる利点を持つこともあります. しかし悩まないでください. なんにせよ, あなたの問題を解決する多くの有効な方法が存在し, あなたはそれらから自分にとって最も理にかなうアプローチに従うことができます.

さあこの辺にしておきましょう. 本書の残りの部分で, R Markdown を最大限活用するために我々が説明した, あらゆるコンポネントを変更する方法のより具体的な例を使って絵の下書きに色をつけることができます.
