# 概念に関する概観 {#conceptual-overview}

このテキストの目標は R Markdown を最大限活用するために多くの豆知識と小技を見せることです. 以降の各章ではより効率的で簡潔なコードを書き, 出力をカスタマイズする技術を実演します. これを始める前に, これらを理解し, 覚え, 応用し, 「リミックス」できる助けになるよう, R Markdown の動作がどうなっているかを少しだけ学んでおくと役に立つでしょう. この節では文書を knit する処理と出力を変更する「重要な切り替えレバー」について簡潔に概観します. この資料は後の章の内容理解に必要ではありません (読み飛ばすのは自由です!) が, 全てのピースをどう当てはめるかについて, より豊かなメンタルモデルを構築する助けになるかもしれません.

## レンダリング時に何が起こっているのか {#rmarkdown-process}

R Markdown はいくつかの異なるプロセスを合わせて文書を作成し, これが R Markdown の全ての部品がどう連動してるかに関する混乱の主な理由です.^[Allison Horst が R Markdown の処理を魔法になぞらえたすばらしいイラストに描き出してくれました (https://github.com/allisonhorst/stats-illustrations/raw/master/rstats-artwork/rmarkdown_wizards.png). そして実際のところ, この絵は本書の表紙絵に使われました.] 幸運にも, ユーザーが文書を作成できるようになるためにはこれらの処理の内部の挙動を全て理解することは必須ではありません. しかし, 文書の挙動の変えようとするだろうユーザーにとっては, どの部品がどの挙動を担当しているかを理解することは重要です. あなたが検索する適切な範囲を絞れるようになれば, ヘルプを探すのがより簡単になります.

R Markdown 文書に対する基本的なワークフローの構造を図\@ref(fig:rmdworkflow)に示します. ステップ (矢印) と, 出力ファイルが生成される前に作成される中間ファイルを強調しています. 全ての処理は `rmarkdown::render()` 関数内で実装されています. 以降は各段階を詳細に説明します.

```{r rmdworkflow, echo = FALSE, fig.cap = "R Markdown 文書がどのように最終的な出力文書に変換されるかを表すダイアグラム", out.width='100%'}
knitr::include_graphics("images/workflow.png", dpi = NA)
```

`.Rmd` 文書は, 文書の本来の形式です. YAML (メタデータ)\index{YAML}, テキスト (ナラティブ), コードチャンク\index{code chunk} を含んでいます.

最初に **knitr**\index{knitr} [@R-knitr] の `knit()` 関数が `.Rmd` ファイルに埋め込まれた全てのコードを実行することになり, そして出力文書にコードの出力を表示します. 全ての結果は, 一時的に作られた `.md` ファイルに含まれるよう, 適正なマークアップ言語へと変換されます.

その後 `.md` ファイルは, あるマークアップ言語のファイルから別のものへと変換するための多用途なツールである Pandoc\index{Pandoc} によって処理されます. 文書を `output` パラメータで指定された (HTML へ出力する `html_document` のような) 出力形式へ変換するため, 文書の YAML フロントマターで指定されたパラメータを取ります (例: `title`, `author`, `date`).

出力形式が PDF ならば, Pandoc が中間ファイルの `.md` を `.tex` ファイルに変換する時にさらに処理が1層, 追加されます. このファイルはその後, 最終的な PDF 文書を形成するため LaTeX によって処理されます. \@ref(install-latex) 節で話したように, **rmarkdown** パッケージは **tinytex** パッケージ @R-tinytex] の `latexmk()` 関数を呼び出し, これが次々に LaTeX を呼び出して `.tex` をコンパイルし `.pdf` にします.

簡潔にまとめると, `rmarkdown::render()` = `knitr::knit()` + Pandoc (PDF の場合のみ + LaTeX) ということです.

Robin Linacre が https://stackoverflow.com/q/40563479/559676 で R Markdown と **knitr** と Pandoc の関係について良い要約を書いてくれました. この投稿には上記の概観よりも技術的に細かい話も含まれています.

全ての R Markdown 文書が常に Pandoc を通してコンパイルされるわけではないことに注意してください. 中間ファイル `.md` は他の Markdown レンダラによってもコンパイルできます. 例えば2つ例を挙げます. 

- **xaringan**\index{xaringan} パッケージ [@R-xaringan] は出力された `.md` をウェブブラウザ上で Markdown コンテンツを表示するための JavaScript ライブラリに渡します.^[**訳注**: **xaringan** について日本語で言及している例は少ないですが, 次のページが用法・技術的な説明の両面で優れています. https://qiita.com/nozma/items/21c56c7319e4fefceb79]

- **blogdown**\index{blogdown} パッケージは [@R-blogdown] `.Rmarkdown` 文書形式をサポートしています. これは `.Rmarkdown` を knit して `.markdown` にし, Markdown 文書は大抵の場合外部のサイトジェネレータによって HTML にレンダリングされます.

## R Markdown の解剖学 {#rmarkdown-anatomy}

R Markdown にいくつかの部品があることを考えながら, 我々は1レベル深く掘り下げることができます. では, レンダリング作業中にいつどのように処理を変化させるかに注目してみましょう.

### YAML メタデータ {#yaml-metadata}

YAML metadata\index{YAML} (YAML ヘッダとも呼びます) はレンダリング処理の中の多くのステージで処理され, 様々な形で最終的な文書に作用することことができます. YAML メタデータは Pandoc, **rmarkdown**, そして **knitr** のそれぞれに読み込まれます. その過程で, メタデータに含まれる情報はコード, コンテンツ, そしてレンダリング処理に影響しうるものです.

典型的な YAML ヘッダはこのように, 文書と基本的なレンダリング操作指示に関する基本的なメタデータを含んでいます.

```yaml
---
title: My R Markdown Report
author: Yihui Xie
output: html_document
---
```

この場合,  `title`, `author` フィールドは Pandoc によって処理され, テンプレート変数の値に設定されます. デフォルトのテンプレートでは, `title` と `author` の情報は得られた文書の冒頭に現れます. Pandoc が YAML ヘッダの情報をどう扱うかのより詳細な話は, Pandoc マニュアルの [YAML metadata block.](https://pandoc.org/MANUAL.html#extension-yaml_metadata_block) に関するセクションで見られます.^[**訳注**: 日本語訳での対応箇所はこちら: https://pandoc-doc-ja.readthedocs.io/ja/latest/users-guide.html#metadata-blocks]

対照的に `output` フィールドはレンダリング処理の中で **rmarkdown** が出力フォーマット関数 `rmarkdown::html_document()` に適用するのに使われます `output` に指定した出力フォーマットに引数をあたえることで, レンダリング処理に影響させることができます. 例えばこのように書きます.

```yaml
output:
  html_document:
    toc: true
    toc_float: true
```

これは `rmarkdown::render()` に, `rmarkdown::html_document(toc = TRUE, toc_float = TRUE)` と指示することと同じです. これらのオプションが何をするのか知るために, あるいは使える他のオプションを知るために, R コンソールで `?rmarkdown::html_document` を実行してヘルプページを読むことになるでしょう. `output: html_document` は `output: rmarkdown::html_document` と等価であることに注意してください. 出力フォーマットが `rmarkdown::` のような修飾子を持たない場合, **rmarkdown** パッケージのものと想定されます. そうでないなら, R パッケージ名のプレフィックスが必要です. 例えば `bookdown::html_document2` のような.

\@ref(parameterized-reports) 節に書いたように, YAML ヘッダ内でパラメータを選択したのなら, コンテンツとコードにも影響することができます. 簡潔に言うと, R Markdown ドキュメント全体で参照可能な変数や R 評価式をヘッダに含めることができるということです. 例えば以下のヘッダでは `start_date` と `end_date` パラメータを定義し, これらは以降の R Markdown 文書内で `params` というリスト内に反映されます. つまり, R コード内でこれらを使うことができ, `params$start_date` と `params$end_date` でアクセスできるということです.

```yaml
---
title: My RMarkdown
author: Yihui Xie
output: html_document
params:
  start_date: '2020-01-01'
  end_date: '2020-06-01'
---
```

### ナラティブ {#narrative}

TODO: ナラティブ, 訳し方
R Markdown のナラティブテキスト要素は YAML メタデータやコードチャンクよりは理解が簡単でしょう. 典型的には, これはテキストエディタで書いているようなものだと感じられるでしょう. しかし Markdown コンテンツは単純なテキストよりも強力で面白いものに違いありません. どちらもコンテンツがどのように作られるかと, 文書の構造がどうやってそこから作られるかについてです.

我々のナラティブの多くは人の手で書かれていますが, 多くの R Markdown 文書がコードと使用される分析を参照しようと望んでいるようです. この理由として, \@ref(document-elements) 章において, コードがテキストの一部を生成するのを助ける様々な方法が実演されています. 単語を結合してリストにしたり (\@ref(combine-words)節), 参考文献リストを書いたり (\@ref(bibliography)節)といったやり方です. この変換は `.Rmd` から `.md` への変換と同様に **knitr**\index{knitr} で制御されます.

Our Markdown text can also provide structure to the document. While we do not have enough space here to review the Markdown syntax,^[Instead, for a review of the Markdown syntax, please see https://bookdown.org/yihui/bookdown/markdown-syntax.html.] one particularly relevant concept is section headers, which are denoted by one or more hashes (`#`) corresponding to different levels, e.g.,

```md
# First-level header

## Second-level header

### Third-level header
```

These headers give structure to our entire document as **rmarkdown** converts the `.md` to our final output format. This structure is useful for referencing and formatting these sections by appending certain attributes to them. To create such references, Pandoc syntax allows us to provide a unique identifier by following the header notation with `{#id}`, or attach one or more classes to a section with `{.class-name}`, e.g.,

```md
## Second-level header {#introduction .important .large}
```

We can then access this section with many of the tools that you will learn, e.g., by referencing it with its ID or class. As examples, Section \@ref(cross-ref) demonstrates how to use the section ID to make cross-references throughout your document, and Section \@ref(html-tabs) introduces the `.tabset` class to help reorganize subsections.

The final interesting type of content that we might find in the textual part of our R Markdown is raw content written specifically for our desired output format, e.g., raw LaTeX code for LaTeX output (Section \@ref(raw-latex)), raw HTML code for HTML output, and so on (Section \@ref(raw-content)). Raw content may help you achieve things that cannot be done with plain Markdown, but please keep in mind that it is usually ignored when the output format is a different format, e.g., raw LaTeX commands in Markdown will be ignored when the output format is HTML.

### Code chunks {#code-chunks}

Code chunks\index{code chunk} are the beating heart of our R Markdown. The code in these chunks is run by **knitr**, and its output is translated to Markdown to dynamically keep our reports in sync with our current scripts and data. Each code chunk consists of a language engine (Chapter \@ref(other-languages)), an optional label, chunk options (Chapter \@ref(chunk-options)), and code.

To understand some of the modifications that we can make to code chunks, it is worth understanding the **knitr** process in slightly more detail. For each chunk, a **knitr** language engine gets three pieces of input: the knitting environment (`knitr::knit_global()`), the code input, and a list of chunk options. It returns the formatted representations of the code as well as its output. As a side effect, the knitting environment may also be modified, e.g., new variables may have been created in this environment via the source code in the code chunk. This process is illustrated in Figure \@ref(fig:knitr-workflow).

```{r knitr-workflow, echo = FALSE, fig.cap = 'A flowchart of inputs and outputs to a language engine.', out.width = '100%', fig.dim=c(7, 3.5), fig.align='center', cache=TRUE}
nomnoml::nomnoml(
  "
  [<frame>Code chunk|
  [Code]->[Language Engine]
  [Chunk Options]->[Language Engine]
  [Environment]->[Language Engine]
  [Language Engine]->[Formatted Code]
  [Language Engine]->[Formatted Output]
  [Language Engine]->[(Modified) Environment]
  ]")
```

We can modify this process by:

- changing our language engine;

- modifying chunk options, which can be global, local, or engine-specific;

- and by using hooks (Chapter \@ref(output-hooks) and Chapter \@ref(chunk-hooks)) to further process these inputs and outputs.

For example, in Section \@ref(hook-hide), you will learn how to add a hook to post-process the code output to redact certain lines in the source code.

Code chunks also have analogous concepts to the classes and unique identifiers that we explored for narratives in Section \@ref(narrative). A code chunk can specify an optional identifier (often called the "chunk label") immediately after its language engine. It can set classes for code and text output blocks in the output document via the chunk options `class.source` and `class.output`, respectively (see Section \@ref(chunk-styling)). For example, the chunk header ```` ```{r summary-stats, class.output = 'large-text'}```` gives this chunk a label `summary-stats`, and the class `large-text` for the text output blocks. A chunk can have only one label, but can have multiple classes.

### Document body {#document-body}
 
One important thing to understand when authoring and modifying a document is how code and narrative pieces create different sections, or containers within the document. For example, suppose we have a document that looks like this:

````md
# Title

## Section X

This is my introduction.

```{r chunk-x}`r ''`
x <- 1
print(x)
```

### Subsection 1

Here are some details.

### Subsection 2

These are more details.

## Section Y

This is another section.

```{r chunk-y}`r ''`
y <- 2
print(y)
```
````

When writing this document, we might think of each piece as linear with independent sections of text and code following in a sequence one after the other. However, what we are actually doing is creating a set of nested containers that conceptually^[In reality, there are many more containers than shown. For example, for a knitted code chunk, the code and output exist in separate containers that share a common parent.] looks more like Figure \@ref(fig:rmd-containers).

```{r rmd-containers, echo = FALSE, fig.cap = 'A simple R Markdown document illustrated as a set of nested containers.', out.width = '50%', fig.align='center', cache=TRUE}
nomnoml::nomnoml(
  "
  [Title (Level 1)|
  
    [Section X (Level 2)| - Text | - Code (chunk-x) | - Subsection 1 | - Subsection 2]
    [Section Y (Level 2)| - Text | - Code (chunk-y) ]

  ]")
```

Two key features of this diagram are (1) every section of text or code is its own discrete container, and (2) containers can be nested within one another. This nesting is particularly apparent if you are authoring your R Markdown document in the RStudio IDE and expand the document outline.

Note that in Figure \@ref(fig:rmd-containers), headers of the same level represent containers at the same level of nesting. Lower-level headers exist inside of the container of higher-level headers. In this case, it is common to call the higher-level sections the "parent" and the minor sections the "child." For example, a subsection is the child of a section. Besides headers, you can also create divisions in your text using `:::`, as demonstrated in Section \@ref(multi-column).

This structure has important implications as we attempt to apply some of the formatting and styling options that are described in this text. For example, we will see this nested structure when we learn about how Pandoc represents our document as an abstract syntax tree (Section \@ref(lua-filters)), or when we use CSS selectors (Section \@ref(html-css), among others) to style our HTML output. 

Formatting and styling can be applied to either containers of similar types (e.g., all code blocks), or all containers that exist inside of another container (e.g., everything under "Section Y"). Additionally, as explained in Section \@ref(narrative), we can apply the same classes to certain sections to designate them as being similar, and in this case, the common class names denote the common properties or intent of these sections.

As you read through this cookbook, it may be useful to quiz yourself and think about what sort of container the specific "recipe" is acting upon.

## What can we change to change the results? {#what-to-change}

Let's summarize what we have seen so far and preview what is to come.

Rendering R Markdown documents with **rmarkdown** consists of converting `.Rmd` to `.md` with **knitr**, and then `.md` to our desired output with Pandoc (typically).

The `.Rmd`-to-`.md` step handles the execution and "translation" of all code within our report, so most changes to *content* involve editing the `.Rmd` with code for **knitr** to translate. Tools that we have control over these steps include **knitr** chunk options and hooks.

Our `.md` is a plain text file with no formatting. This is where Pandoc comes in to convert to the final output format such as HTML, PDF, or Word. Along the way, we add structure and style. A wide range of tools to help us in this process include style sheets (CSS), raw LaTeX or HTML code, Pandoc templates, and Lua filters. By understanding the nested structure of an R Markdown document, and by thoughtfully using identifiers and classes, we can apply some of these tools selectively to targeted parts of our output.

Finally, our YAML metadata may help us toggle any of these steps. Changing parameters can change how our code runs, changing metadata alters the text content, and changing output options provides the `render()` function with a different set of instructions.

Of course, these are all rough heuristics and should not be taken as absolute facts. Ultimately, there is not a completely clear division of labor. Throughout this book, you will see that there are often multiple valid paths to achieving many of the outcomes described in this book, and these may enter different stages of the pipeline. For example, for the simple task of inserting in image in your document, you may either use the R code `knitr::include_graphics()`, which would execute in the `.Rmd` to `.md` stage, or directly use Markdown syntax (`![]()`). This may seem confusing, and sometimes different approaches will have different advantages. However, do not be concerned---if anything, this often means there are many valid ways to solve your problem, and you can follow whichever approach makes the most sense to you.

And that's that! In the rest of the book, you can now color in this rough sketch with many more concrete examples of ways to modify all of the components that we have discussed to get the most value out of R Markdown.
